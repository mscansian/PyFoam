

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pandas.core.generic &mdash; PyFoam 0.6.6 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PyFoam 0.6.6 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../../../index.html" class="fa fa-home"> PyFoam</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">API documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api/PyFoam.html">PyFoam package</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">PyFoam</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>pandas.core.generic</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for pandas.core.generic</h1><div class="highlight"><pre>
<span class="c"># pylint: disable=W0231,E1101</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas.lib</span> <span class="kn">as</span> <span class="nn">lib</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pandas.core.base</span> <span class="kn">import</span> <span class="n">PandasObject</span>
<span class="kn">from</span> <span class="nn">pandas.core.index</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">,</span> <span class="n">_ensure_index</span><span class="p">,</span>
                               <span class="n">InvalidIndexError</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">pandas.core.indexing</span> <span class="kn">as</span> <span class="nn">indexing</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.index</span> <span class="kn">import</span> <span class="n">DatetimeIndex</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.period</span> <span class="kn">import</span> <span class="n">PeriodIndex</span>
<span class="kn">from</span> <span class="nn">pandas.core.internals</span> <span class="kn">import</span> <span class="n">BlockManager</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="kn">as</span> <span class="nn">com</span>
<span class="kn">import</span> <span class="nn">pandas.core.datetools</span> <span class="kn">as</span> <span class="nn">datetools</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">compat</span>
<span class="kn">from</span> <span class="nn">pandas.compat</span> <span class="kn">import</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="n">lrange</span><span class="p">,</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">isidentifier</span>
<span class="kn">from</span> <span class="nn">pandas.core.common</span> <span class="kn">import</span> <span class="p">(</span><span class="n">isnull</span><span class="p">,</span> <span class="n">notnull</span><span class="p">,</span> <span class="n">is_list_like</span><span class="p">,</span>
                                <span class="n">_values_from_object</span><span class="p">,</span> <span class="n">_maybe_promote</span><span class="p">,</span>
                                <span class="n">_maybe_box_datetimelike</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span>
                                <span class="n">SettingWithCopyError</span><span class="p">,</span> <span class="n">SettingWithCopyWarning</span><span class="p">,</span>
                                <span class="n">AbstractMethodError</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">pandas.core.nanops</span> <span class="kn">as</span> <span class="nn">nanops</span>
<span class="kn">from</span> <span class="nn">pandas.util.decorators</span> <span class="kn">import</span> <span class="n">Appender</span><span class="p">,</span> <span class="n">Substitution</span><span class="p">,</span> <span class="n">deprecate_kwarg</span>
<span class="kn">from</span> <span class="nn">pandas.core</span> <span class="kn">import</span> <span class="n">config</span>

<span class="c"># goal is to be able to define the docs close to function, while still being</span>
<span class="c"># able to share</span>
<span class="n">_shared_docs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">_shared_doc_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="s">&#39;keywords for axes&#39;</span><span class="p">,</span>
                          <span class="n">klass</span><span class="o">=</span><span class="s">&#39;NDFrame&#39;</span><span class="p">,</span>
                          <span class="n">axes_single_arg</span><span class="o">=</span><span class="s">&#39;int or labels for object&#39;</span><span class="p">,</span>
                          <span class="n">args_transpose</span><span class="o">=</span><span class="s">&#39;axes to permute (int or label for&#39;</span>
                                         <span class="s">&#39; object)&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_dictlike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">com</span><span class="o">.</span><span class="n">ABCSeries</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_single_replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_replace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;cannot replace {0} with method {1} on a {2}&#39;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

    <span class="n">orig_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">fill_f</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_get_fill_func</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">mask_missing</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">to_replace</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">fill_f</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">orig_dtype</span> <span class="ow">and</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">NDFrame</span><span class="p">(</span><span class="n">PandasObject</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    N-dimensional analogue of DataFrame. Store multi-dimensional in a</span>
<span class="sd">    size-mutable, labeled data structure</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : BlockManager</span>
<span class="sd">    axes : list</span>
<span class="sd">    copy : boolean, default False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_internal_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;_data&#39;</span><span class="p">,</span> <span class="s">&#39;_cacher&#39;</span><span class="p">,</span> <span class="s">&#39;_item_cache&#39;</span><span class="p">,</span> <span class="s">&#39;_cache&#39;</span><span class="p">,</span>
                       <span class="s">&#39;is_copy&#39;</span><span class="p">,</span> <span class="s">&#39;_subtyp&#39;</span><span class="p">,</span> <span class="s">&#39;_index&#39;</span><span class="p">,</span>
                       <span class="s">&#39;_default_kind&#39;</span><span class="p">,</span> <span class="s">&#39;_default_fill_value&#39;</span><span class="p">,</span>
                       <span class="s">&#39;__array_struct__&#39;</span><span class="p">,</span><span class="s">&#39;__array_interface__&#39;</span><span class="p">]</span>
    <span class="n">_internal_names_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_internal_names</span><span class="p">)</span>
    <span class="n">_accessors</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([])</span>
    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">is_copy</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">fastpath</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fastpath</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

        <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;is_copy&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_data&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_item_cache&#39;</span><span class="p">,</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">_validate_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; validate the passed dtype &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_coerce_to_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c"># a compound dtype</span>
            <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;V&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;compound dtypes are not implemented&quot;</span>
                                          <span class="s">&quot;in the {0} constructor&quot;</span>
                                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">_init_mgr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mgr</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; passed a manager and a axes dict &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">axe</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">axe</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span>
                    <span class="n">axe</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="c"># make a copy if explicitly requested</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># avoid further copies if we can</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mgr</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Construction</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># unicode representation based upon iterating over self</span>
        <span class="c"># (since, by definition, `PandasContainers` are iterable)</span>
        <span class="n">prepr</span> <span class="o">=</span> <span class="s">&#39;[</span><span class="si">%s</span><span class="s">]&#39;</span> <span class="o">%</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">pprint_thing</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">prepr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dir_additions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add the string-like attributes from the info_axis &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isidentifier</span><span class="p">(</span><span class="n">c</span><span class="p">)])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_expanddim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Axis</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_setup_axes</span><span class="p">(</span>
        <span class="n">cls</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">info_axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stat_axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">aliases</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">slicers</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">axes_are_reversed</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">build_axes</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ns</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; provide axes setup for the major PandasObjects</span>

<span class="sd">            axes : the names of the axes in order (lowest to highest)</span>
<span class="sd">            info_axis_num : the axis of the selector dimension (int)</span>
<span class="sd">            stat_axis_num : the number of axis for the default stats (int)</span>
<span class="sd">            aliases : other names for a single axis (dict)</span>
<span class="sd">            slicers : how axes slice to others (dict)</span>
<span class="sd">            axes_are_reversed : boolean whether to treat passed axes as</span>
<span class="sd">                reversed (DataFrame)</span>
<span class="sd">            build_axes : setup the axis properties (default True)</span>
<span class="sd">            &quot;&quot;&quot;</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span> <span class="o">=</span> <span class="n">axes</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_NUMBERS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_ALIASES</span> <span class="o">=</span> <span class="n">aliases</span> <span class="ow">or</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_IALIASES</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                                  <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_ALIASES</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_NAMES</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_SLICEMAP</span> <span class="o">=</span> <span class="n">slicers</span> <span class="ow">or</span> <span class="bp">None</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span> <span class="o">=</span> <span class="n">axes_are_reversed</span>

        <span class="c"># typ</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s">&#39;_typ&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

        <span class="c"># indexing support</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_ix</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">info_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_info_axis_number</span> <span class="o">=</span> <span class="n">info_axis</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_info_axis_name</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">info_axis</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">stat_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_stat_axis_number</span> <span class="o">=</span> <span class="n">stat_axis</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_stat_axis_name</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">stat_axis</span><span class="p">]</span>

        <span class="c"># setup the actual axis</span>
        <span class="k">if</span> <span class="n">build_axes</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">set_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">lib</span><span class="o">.</span><span class="n">AxisProperty</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">_internal_names_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">axes_are_reversed</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">set_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">set_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="c"># addtl parms</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_axes_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return an axes dictionary for myself &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">axes</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)])</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_construct_axes_dict_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return an axes dictionary for the passed axes &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">,</span> <span class="n">axes</span><span class="p">)])</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_construct_axes_dict_for_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return an axes dictionary for myself &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_SLICEMAP</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                 <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">axes</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)])</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_construct_axes_from_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">require_all</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; construct and returns axes if supplied in args/kwargs</span>
<span class="sd">            if require_all, raise if all axis arguments are not supplied</span>
<span class="sd">            return a tuple of (axes, kwargs) &quot;&quot;&quot;</span>

        <span class="c"># construct the args</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>

            <span class="c"># if we have an alias for this axis</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_IALIASES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s">&quot;arguments are mutually exclusive for [</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">]&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="c"># look for a argument by position</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">require_all</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s">&quot;not enough/duplicate arguments specified!&quot;</span><span class="p">)</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_axes</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># for construction from BlockManager</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">:</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_construct_axes_dict_from</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_axis_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ALIASES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">axis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NUMBERS</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;No axis named {0} for object type {1}&#39;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_get_axis_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ALIASES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NUMBERS</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">axis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;No axis named {0} for object type {1}&#39;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_get_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_block_manager_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; map the axis to the block_manager axis &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">m</span> <span class="o">-</span> <span class="n">axis</span>
        <span class="k">return</span> <span class="n">axis</span>

    <span class="k">def</span> <span class="nf">_get_axis_resolvers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="c"># index or columns</span>
        <span class="n">axis_index</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axis_index</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">level</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># prefix with &#39;i&#39; or &#39;c&#39; depending on the input axis</span>
                <span class="c"># e.g., you must do ilevel_0 for the 0th level of an unnamed</span>
                <span class="c"># multiiindex</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s">&#39;{prefix}level_{i}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">i</span>

            <span class="n">level_values</span> <span class="o">=</span> <span class="n">axis_index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">level_values</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>
            <span class="n">s</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">axis_index</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

        <span class="c"># put the index/columns itself in the dict</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis_index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">dindex</span> <span class="o">=</span> <span class="n">axis_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dindex</span> <span class="o">=</span> <span class="n">axis_index</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>

        <span class="n">d</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">dindex</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_get_index_resolvers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">axis_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_resolvers</span><span class="p">(</span><span class="n">axis_name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_info_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_stat_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;tuple of axis dimensions&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;index(es) of the NDFrame&quot;</span>
        <span class="c"># we do it this way because if we have reversed axes, then</span>
        <span class="c"># the block manager shows then reversed</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;Number of axes / array dimensions&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">ndim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;number of elements in the NDFrame&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expand_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ax</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ax</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;O&#39;</span><span class="p">)</span>
                <span class="n">new_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">),</span> <span class="n">k</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_axes</span>

    <span class="k">def</span> <span class="nf">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; public verson of axis assignment &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span><span class="n">labels</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;transpose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">        Permute the dimensions of the </span><span class="si">%(klass)s</span><span class="s"></span>

<span class="s">        Parameters</span>
<span class="s">        ----------</span>
<span class="s">        args : </span><span class="si">%(args_transpose)s</span><span class="s"></span>
<span class="s">        copy : boolean, default False</span>
<span class="s">            Make a copy of the underlying data. Mixed-dtype data will</span>
<span class="s">            always result in a copy</span>

<span class="s">        Examples</span>
<span class="s">        --------</span>
<span class="s">        &gt;&gt;&gt; p.transpose(2, 0, 1)</span>
<span class="s">        &gt;&gt;&gt; p.transpose(2, 0, 1, copy=True)</span>

<span class="s">        Returns</span>
<span class="s">        -------</span>
<span class="s">        y : same as input</span>
<span class="s">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;transpose&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c"># construct the args</span>
        <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_from_arguments</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">require_all</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">axes_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">])</span>
        <span class="n">axes_numbers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                             <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">])</span>

        <span class="c"># we must have unique axes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Must specify </span><span class="si">%s</span><span class="s"> unique axes&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span>

        <span class="n">new_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict_from</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">axes_names</span><span class="p">])</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes_numbers</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;copy&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;transpose() got an unexpected keyword &#39;</span>
                    <span class="s">&#39;argument &quot;{0}&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="o">**</span><span class="n">new_axes</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interchange axes and swap values axes appropriately</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : same as input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis1</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span>

        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">))</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="o">*</span><span class="n">new_axes</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return item and drop from frame. Raise KeyError if not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; squeeze length 1 dimensions &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                  <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">])]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">swaplevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Swap levels i and j in a MultiIndex on a particular axis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i, j : int, string (can be mixed)</span>
<span class="sd">            Level of index to be swapped. Can pass level name as string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        swapped : type of caller (new object)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Rename</span>

    <span class="c"># TODO: define separate funcs for DataFrame, Series and Panel so you can</span>
    <span class="c"># get completion on keyword arguments.</span>
    <span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;rename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">        Alter axes input function or functions. Function / dict values must be</span>
<span class="s">        unique (1-to-1). Labels not contained in a dict / Series will be left</span>
<span class="s">        as-is.</span>

<span class="s">        Parameters</span>
<span class="s">        ----------</span>
<span class="s">        </span><span class="si">%(axes)s</span><span class="s"> : dict-like or function, optional</span>
<span class="s">            Transformation to apply to that axis values</span>

<span class="s">        copy : boolean, default True</span>
<span class="s">            Also copy underlying data</span>
<span class="s">        inplace : boolean, default False</span>
<span class="s">            Whether to return a new </span><span class="si">%(klass)s</span><span class="s">. If True then value of copy is</span>
<span class="s">            ignored.</span>

<span class="s">        Returns</span>
<span class="s">        -------</span>
<span class="s">        renamed : </span><span class="si">%(klass)s</span><span class="s"> (new object)</span>
<span class="s">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;rename&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="s">&#39;axes keywords for this&#39;</span>
                                            <span class="s">&#39; object&#39;</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="s">&#39;NDFrame&#39;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_from_arguments</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;copy&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;inplace&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;rename() got an unexpected keyword &#39;</span>
                    <span class="s">&#39;argument &quot;{0}&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">_count_not_none</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;must pass an index to rename&#39;</span><span class="p">)</span>

        <span class="c"># renamer function if passed a dict</span>
        <span class="k">def</span> <span class="nf">_get_rename_function</span><span class="p">(</span><span class="n">mapper</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
                <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mapper</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">mapper</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">x</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">mapper</span>

            <span class="k">return</span> <span class="n">f</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="c"># start in the axis order to eliminate too many copies</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">lrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">_get_rename_function</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="n">baxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">baxis</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">rename</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;rename&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">rename_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alter index and / or columns using input function or functions.</span>
<span class="sd">        Function / dict values must be unique (1-to-1). Labels not contained in</span>
<span class="sd">        a dict / Series will be left as-is.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapper : dict-like or function, optional</span>
<span class="sd">        axis : int or string, default 0</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            Also copy underlying data</span>
<span class="sd">        inplace : boolean, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;copy&#39;</span><span class="p">:</span> <span class="n">copy</span><span class="p">,</span> <span class="s">&#39;inplace&#39;</span><span class="p">:</span> <span class="n">inplace</span><span class="p">}</span>
        <span class="n">d</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapper</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Comparisons</span>

    <span class="k">def</span> <span class="nf">_indexed_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>

            <span class="c"># inv fails with 0 len</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span>

            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if two NDFrame objects contain the same elements. NaNs in the</span>
<span class="sd">        same location are considered equal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Iteration</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;{0!r} objects are mutable, thus they cannot be&#39;</span>
                        <span class="s">&#39; hashed&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over infor axis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">)</span>

    <span class="c"># can we get a better explanation of this?</span>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the &#39;info axis&#39; (see Indexing for more)</span>

<span class="sd">        This is index for Series, columns for DataFrame and major_axis for</span>
<span class="sd">        Panel.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>

    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over (label, values) on info axis</span>

<span class="sd">        This is index for Series, columns for DataFrame, major_axis for Panel,</span>
<span class="sd">        and so on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>

    <span class="c"># originally used to get around 2to3&#39;s changes to iteritems.</span>
    <span class="c"># Now unnecessary. Sidenote: don&#39;t want to deprecate this for a while,</span>
    <span class="c"># otherwise libraries that use 2to3 will have issues.</span>
    <span class="k">def</span> <span class="nf">iterkv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">&quot;iteritems alias used to get around 2to3. Deprecated&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;iterkv is deprecated and will be removed in a future &quot;</span>
                      <span class="s">&quot;release, use ``iteritems`` instead.&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns length of info axis &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the key is in the info axis &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;True if NDFrame is entirely empty [no items]&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The truth value of a {0} is ambiguous. &quot;</span>
                         <span class="s">&quot;Use a.empty, a.bool(), a.item(), a.any() or a.all().&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

    <span class="n">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

    <span class="k">def</span> <span class="nf">bool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the bool of a single element PandasObject</span>
<span class="sd">            This must be a boolean scalar value, either True or False</span>

<span class="sd">            Raise a ValueError if the PandasObject does not have exactly</span>
<span class="sd">            1 element, or that element is not boolean &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;bool cannot act on a non-boolean single element &quot;</span>
                             <span class="s">&quot;{0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__nonzero__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Array Interface</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c"># ideally we would define this to avoid the getattr checks, but</span>
    <span class="c"># is slower</span>
    <span class="c">#@property</span>
    <span class="c">#def __array_interface__(self):</span>
    <span class="c">#    &quot;&quot;&quot; provide numpy array interface method &quot;&quot;&quot;</span>
    <span class="c">#    values = self.values</span>
    <span class="c">#    return dict(typestr=values.dtype.str,shape=values.shape,data=values)</span>

    <span class="k">def</span> <span class="nf">to_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;Return dense representation of NDFrame (as opposed to sparse)&quot;</span>
        <span class="c"># compat</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Picklability</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;_typ&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">typ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>

                <span class="c"># set in the order of internal names</span>
                <span class="c"># to avoid definitional recursion</span>
                <span class="c"># e.g. say fill_value needing _data to be</span>
                <span class="c"># defined</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal_names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">meta</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">state</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">meta</span><span class="p">:</span>
                        <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_series_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_sparse_frame_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_frame_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_panel_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_series_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># pragma: no cover</span>
            <span class="c"># old pickling format, for compatibility</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_matrix_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># IO</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># I/O Methods</span>

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_or_buf</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">date_format</span><span class="o">=</span><span class="s">&#39;epoch&#39;</span><span class="p">,</span>
                <span class="n">double_precision</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">force_ascii</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">date_unit</span><span class="o">=</span><span class="s">&#39;ms&#39;</span><span class="p">,</span>
                <span class="n">default_handler</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the object to a JSON string.</span>

<span class="sd">        Note NaN&#39;s and None will be converted to null and datetime objects</span>
<span class="sd">        will be converted to UNIX timestamps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buf : the path or buffer to write the result string</span>
<span class="sd">            if this is None, return a StringIO of the converted string</span>
<span class="sd">        orient : string</span>

<span class="sd">            * Series</span>

<span class="sd">              - default is &#39;index&#39;</span>
<span class="sd">              - allowed values are: {&#39;split&#39;,&#39;records&#39;,&#39;index&#39;}</span>

<span class="sd">            * DataFrame</span>

<span class="sd">              - default is &#39;columns&#39;</span>
<span class="sd">              - allowed values are:</span>
<span class="sd">                {&#39;split&#39;,&#39;records&#39;,&#39;index&#39;,&#39;columns&#39;,&#39;values&#39;}</span>

<span class="sd">            * The format of the JSON string</span>

<span class="sd">              - split : dict like</span>
<span class="sd">                {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}</span>
<span class="sd">              - records : list like</span>
<span class="sd">                [{column -&gt; value}, ... , {column -&gt; value}]</span>
<span class="sd">              - index : dict like {index -&gt; {column -&gt; value}}</span>
<span class="sd">              - columns : dict like {column -&gt; {index -&gt; value}}</span>
<span class="sd">              - values : just the values array</span>

<span class="sd">        date_format : {&#39;epoch&#39;, &#39;iso&#39;}</span>
<span class="sd">            Type of date conversion. `epoch` = epoch milliseconds,</span>
<span class="sd">            `iso`` = ISO8601, default is epoch.</span>
<span class="sd">        double_precision : The number of decimal places to use when encoding</span>
<span class="sd">            floating point values, default 10.</span>
<span class="sd">        force_ascii : force encoded string to be ASCII, default True.</span>
<span class="sd">        date_unit : string, default &#39;ms&#39; (milliseconds)</span>
<span class="sd">            The time unit to encode to, governs timestamp and ISO8601</span>
<span class="sd">            precision.  One of &#39;s&#39;, &#39;ms&#39;, &#39;us&#39;, &#39;ns&#39; for second, millisecond,</span>
<span class="sd">            microsecond, and nanosecond respectively.</span>
<span class="sd">        default_handler : callable, default None</span>
<span class="sd">            Handler to call if object cannot otherwise be converted to a</span>
<span class="sd">            suitable format for JSON. Should receive a single argument which is</span>
<span class="sd">            the object to convert and return a serialisable object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same type as input object with filtered info axis</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="kn">import</span> <span class="n">json</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span>
            <span class="n">path_or_buf</span><span class="o">=</span><span class="n">path_or_buf</span><span class="p">,</span>
            <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="n">orient</span><span class="p">,</span>
            <span class="n">date_format</span><span class="o">=</span><span class="n">date_format</span><span class="p">,</span>
            <span class="n">double_precision</span><span class="o">=</span><span class="n">double_precision</span><span class="p">,</span>
            <span class="n">force_ascii</span><span class="o">=</span><span class="n">force_ascii</span><span class="p">,</span>
            <span class="n">date_unit</span><span class="o">=</span><span class="n">date_unit</span><span class="p">,</span>
            <span class="n">default_handler</span><span class="o">=</span><span class="n">default_handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_hdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_or_buf</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; activate the HDFStore</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buf : the path (string) or buffer to put the store</span>
<span class="sd">        key : string</span>
<span class="sd">            indentifier for the group in the store</span>
<span class="sd">        mode : optional, {&#39;a&#39;, &#39;w&#39;, &#39;r&#39;, &#39;r+&#39;}, default &#39;a&#39;</span>

<span class="sd">          ``&#39;r&#39;``</span>
<span class="sd">              Read-only; no data can be modified.</span>
<span class="sd">          ``&#39;w&#39;``</span>
<span class="sd">              Write; a new file is created (an existing file with the same</span>
<span class="sd">              name would be deleted).</span>
<span class="sd">          ``&#39;a&#39;``</span>
<span class="sd">              Append; an existing file is opened for reading and writing,</span>
<span class="sd">              and if the file does not exist it is created.</span>
<span class="sd">          ``&#39;r+&#39;``</span>
<span class="sd">              It is similar to ``&#39;a&#39;``, but the file must already exist.</span>
<span class="sd">        format   : &#39;fixed(f)|table(t)&#39;, default is &#39;fixed&#39;</span>
<span class="sd">            fixed(f) : Fixed format</span>
<span class="sd">                       Fast writing/reading. Not-appendable, nor searchable</span>
<span class="sd">            table(t) : Table format</span>
<span class="sd">                       Write as a PyTables Table structure which may perform</span>
<span class="sd">                       worse but allow more flexible operations like searching</span>
<span class="sd">                       / selecting subsets of the data</span>
<span class="sd">        append   : boolean, default False</span>
<span class="sd">            For Table formats, append the input data to the existing</span>
<span class="sd">        complevel : int, 1-9, default 0</span>
<span class="sd">            If a complib is specified compression will be applied</span>
<span class="sd">            where possible</span>
<span class="sd">        complib : {&#39;zlib&#39;, &#39;bzip2&#39;, &#39;lzo&#39;, &#39;blosc&#39;, None}, default None</span>
<span class="sd">            If complevel is &gt; 0 apply compression to objects written</span>
<span class="sd">            in the store wherever possible</span>
<span class="sd">        fletcher32 : bool, default False</span>
<span class="sd">            If applying compression use the fletcher32 checksum</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="kn">import</span> <span class="n">pytables</span>
        <span class="k">return</span> <span class="n">pytables</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="n">path_or_buf</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_msgpack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_or_buf</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        msgpack (serialize) object to input file path</span>

<span class="sd">        THIS IS AN EXPERIMENTAL LIBRARY and the storage format</span>
<span class="sd">        may not be stable until a future release.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string File path, buffer-like, or None</span>
<span class="sd">            if None, return generated string</span>
<span class="sd">        append : boolean whether to append to an existing msgpack</span>
<span class="sd">            (default is False)</span>
<span class="sd">        compress : type of compressor (zlib or blosc), default to None (no</span>
<span class="sd">            compression)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="kn">import</span> <span class="n">packers</span>
        <span class="k">return</span> <span class="n">packers</span><span class="o">.</span><span class="n">to_msgpack</span><span class="p">(</span><span class="n">path_or_buf</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_sql</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">con</span><span class="p">,</span> <span class="n">flavor</span><span class="o">=</span><span class="s">&#39;sqlite&#39;</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s">&#39;fail&#39;</span><span class="p">,</span>
               <span class="n">index</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">index_label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write records stored in a DataFrame to a SQL database.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            Name of SQL table</span>
<span class="sd">        con : SQLAlchemy engine or DBAPI2 connection (legacy mode)</span>
<span class="sd">            Using SQLAlchemy makes it possible to use any DB supported by that</span>
<span class="sd">            library.</span>
<span class="sd">            If a DBAPI2 object, only sqlite3 is supported.</span>
<span class="sd">        flavor : {&#39;sqlite&#39;, &#39;mysql&#39;}, default &#39;sqlite&#39;</span>
<span class="sd">            The flavor of SQL to use. Ignored when using SQLAlchemy engine.</span>
<span class="sd">            &#39;mysql&#39; is deprecated and will be removed in future versions, but it</span>
<span class="sd">            will be further supported through SQLAlchemy engines.</span>
<span class="sd">        schema : string, default None</span>
<span class="sd">            Specify the schema (if database flavor supports this). If None, use</span>
<span class="sd">            default schema.</span>
<span class="sd">        if_exists : {&#39;fail&#39;, &#39;replace&#39;, &#39;append&#39;}, default &#39;fail&#39;</span>
<span class="sd">            - fail: If table exists, do nothing.</span>
<span class="sd">            - replace: If table exists, drop it, recreate it, and insert data.</span>
<span class="sd">            - append: If table exists, insert data. Create if does not exist.</span>
<span class="sd">        index : boolean, default True</span>
<span class="sd">            Write DataFrame index as a column.</span>
<span class="sd">        index_label : string or sequence, default None</span>
<span class="sd">            Column label for index column(s). If None is given (default) and</span>
<span class="sd">            `index` is True, then the index names are used.</span>
<span class="sd">            A sequence should be given if the DataFrame uses MultiIndex.</span>
<span class="sd">        chunksize : int, default None</span>
<span class="sd">            If not None, then rows will be written in batches of this size at a</span>
<span class="sd">            time.  If None, all rows will be written at once.</span>
<span class="sd">        dtype : dict of column name to SQL type, default None</span>
<span class="sd">            Optional specifying the datatype for columns. The SQL type should</span>
<span class="sd">            be a SQLAlchemy type, or a string for sqlite3 fallback connection.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="kn">import</span> <span class="n">sql</span>
        <span class="n">sql</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">con</span><span class="p">,</span> <span class="n">flavor</span><span class="o">=</span><span class="n">flavor</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="n">if_exists</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">index_label</span><span class="o">=</span><span class="n">index_label</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pickle (serialize) object to input file path</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string</span>
<span class="sd">            File path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.pickle</span> <span class="kn">import</span> <span class="n">to_pickle</span>
        <span class="k">return</span> <span class="n">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>  <span class="c"># TODO remove in 0.14</span>
        <span class="s">&quot;Deprecated. Use to_pickle instead&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="kn">from</span> <span class="nn">pandas.io.pickle</span> <span class="kn">import</span> <span class="n">to_pickle</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;save is deprecated, use to_pickle&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>  <span class="c"># TODO remove in 0.14</span>
        <span class="s">&quot;Deprecated. Use read_pickle instead.&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="kn">from</span> <span class="nn">pandas.io.pickle</span> <span class="kn">import</span> <span class="n">read_pickle</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;load is deprecated, use pd.read_pickle&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">read_pickle</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_clipboard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to write text representation of object to the system clipboard</span>
<span class="sd">        This can be pasted into Excel, for example.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        excel : boolean, defaults to True</span>
<span class="sd">                if True, use the provided separator, writing in a csv</span>
<span class="sd">                format for allowing easy pasting into excel.</span>
<span class="sd">                if False, write a string representation of the object</span>
<span class="sd">                to the clipboard</span>
<span class="sd">        sep : optional, defaults to tab</span>
<span class="sd">        other keywords are passed to to_csv</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Requirements for your platform</span>
<span class="sd">          - Linux: xclip, or xsel (with gtk or PyQt4 modules)</span>
<span class="sd">          - Windows: none</span>
<span class="sd">          - OS X: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="kn">import</span> <span class="n">clipboard</span>
        <span class="n">clipboard</span><span class="o">.</span><span class="n">to_clipboard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excel</span><span class="o">=</span><span class="n">excel</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Fancy Indexing</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_indexer</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">indexer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; create an indexer like _name in the class &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">iname</span> <span class="o">=</span> <span class="s">&#39;_</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">name</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">iname</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iname</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iname</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">i</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">_indexer</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">indexer</span><span class="o">.</span><span class="n">__doc__</span><span class="p">))</span>

            <span class="c"># add to our internal names set</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_internal_names_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">iname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get item from object for given key (DataFrame column, Panel slice,</span>
<span class="sd">        etc.). Returns default value if not found</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : type of items contained in object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_item_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the cached item, item represents a label indexer &quot;&quot;&quot;</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_box_item_values</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_set_as_cached</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="c"># for a chain</span>
            <span class="n">res</span><span class="o">.</span><span class="n">is_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_set_as_cached</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">cacher</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; set the _cacher attribute on the calling object with</span>
<span class="sd">            a weakref to cacher &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cacher</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">cacher</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_iget_item_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the cached item, item represents a positional indexer &quot;&quot;&quot;</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>
        <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_number</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lower</span>

    <span class="k">def</span> <span class="nf">_box_item_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_maybe_cache_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        the object has called back to us saying</span>
<span class="sd">        maybe it has changed</span>

<span class="sd">        numpy &lt; 1.8 has an issue with object arrays and aliasing</span>
<span class="sd">        GH6026</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">_np_version_under1p8</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_cached</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; boolean : return if I am cached &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_cacher&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_get_cacher</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return my cacher or None &quot;&quot;&quot;</span>
        <span class="n">cacher</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_cacher&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cacher</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cacher</span> <span class="o">=</span> <span class="n">cacher</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span>
        <span class="k">return</span> <span class="n">cacher</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; boolean : return if I am a view of another array &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_view</span>

    <span class="k">def</span> <span class="nf">_maybe_update_cacher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">verify_is_copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        see if we need to update our parent cacher</span>
<span class="sd">        if clear, then clear our cache</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clear : boolean, default False</span>
<span class="sd">            clear the item cache</span>
<span class="sd">        verify_is_copy : boolean, default True</span>
<span class="sd">            provide is_copy checks</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cacher</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_cacher&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cacher</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">cacher</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span>

            <span class="c"># we are trying to reference a dead referant, hence</span>
            <span class="c"># a copy</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cacher</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ref</span><span class="o">.</span><span class="n">_maybe_cache_changed</span><span class="p">(</span><span class="n">cacher</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">if</span> <span class="n">verify_is_copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">(</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s">&#39;referant&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_clear_item_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slobj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a slice of this container.</span>

<span class="sd">        kind parameter is maintained for compatibility with Series slicing.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">slobj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># this could be a view</span>
        <span class="c"># but only in a single-dtyped view slicable case</span>
        <span class="n">is_copy</span> <span class="o">=</span> <span class="n">axis</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">result</span><span class="o">.</span><span class="n">_is_view</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">is_copy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_set_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_check_is_chained_assignment_possible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if we are a view, have a cacher, and are of mixed type</span>
<span class="sd">        if so, then force a setitem_copy check</span>

<span class="sd">        should be called just near setting a value</span>

<span class="sd">        will return a boolean if it we are a view and are cached, but a single-dtype</span>
<span class="sd">        meaning that the cacher should be updated following setting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_view</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_cached</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cacher</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">ref</span><span class="o">.</span><span class="n">_is_mixed_type</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">(</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s">&#39;referant&#39;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">(</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s">&#39;referant&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_check_setitem_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s">&#39;setting&#39;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stacklevel : integer, default 4</span>
<span class="sd">           the level to show of the stack when the error is output</span>
<span class="sd">        t : string, the type of setting error</span>
<span class="sd">        force : boolean, default False</span>
<span class="sd">           if True, then force showing an error</span>

<span class="sd">        validate if we are doing a settitem on a chained copy.</span>

<span class="sd">        If you call this function, be sure to set the stacklevel such that the</span>
<span class="sd">        user will see the error *at the level of setting*</span>

<span class="sd">        It is technically possible to figure out that we are setting on</span>
<span class="sd">        a copy even WITH a multi-dtyped pandas object. In other words, some blocks</span>
<span class="sd">        may be views while other are not. Currently _is_view will ALWAYS return False</span>
<span class="sd">        for multi-blocks to avoid having to handle this case.</span>

<span class="sd">        df = DataFrame(np.arange(0,9), columns=[&#39;count&#39;])</span>
<span class="sd">        df[&#39;group&#39;] = &#39;b&#39;</span>

<span class="sd">        # this technically need not raise SettingWithCopy if both are view (which is not</span>
<span class="sd">        # generally guaranteed but is usually True</span>
<span class="sd">        # however, this is in general not a good practice and we recommend using .loc</span>
<span class="sd">        df.iloc[0:5][&#39;group&#39;] = &#39;a&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">force</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span><span class="p">:</span>

            <span class="n">value</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s">&#39;mode.chained_assignment&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="c"># see if the copy is not actually refererd; if so, then disolve</span>
            <span class="c"># the copy weakref</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_referents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span><span class="p">()):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">return</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c"># we might be a false positive</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">return</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c"># a custom message</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span>

            <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="s">&#39;referant&#39;</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
                     <span class="s">&quot;A value is trying to be set on a copy of a slice from a &quot;</span>
                     <span class="s">&quot;DataFrame</span><span class="se">\n\n</span><span class="s">&quot;</span>
                     <span class="s">&quot;See the the caveats in the documentation: &quot;</span>
                     <span class="s">&quot;http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
                     <span class="s">&quot;A value is trying to be set on a copy of a slice from a &quot;</span>
                     <span class="s">&quot;DataFrame.</span><span class="se">\n</span><span class="s">&quot;</span>
                     <span class="s">&quot;Try using .loc[row_indexer,col_indexer] = value instead</span><span class="se">\n\n</span><span class="s">&quot;</span>
                     <span class="s">&quot;See the the caveats in the documentation: &quot;</span>
                     <span class="s">&quot;http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s">&#39;raise&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SettingWithCopyError</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="s">&#39;warn&#39;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">SettingWithCopyWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="n">stacklevel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete item</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deleted</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">maybe_shortcut</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;columns&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">maybe_shortcut</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_engine</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">maybe_shortcut</span><span class="p">:</span>
            <span class="c"># Allow shorthand to delete all columns whose first len(key)</span>
            <span class="c"># elements match key:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">col</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="n">deleted</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">deleted</span><span class="p">:</span>
            <span class="c"># If the above loop ran and didn&#39;t delete anything because</span>
            <span class="c"># there was no match, this call should raise the appropriate</span>
            <span class="c"># exception:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">is_copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analogous to ndarray.take</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : list / array of ints</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">        convert : translate neg to pos indices (default)</span>
<span class="sd">        is_copy : mark the returned frame as a copy</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        taken : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span>
                                   <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span>
                                   <span class="n">convert</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># maybe set copy if we didn&#39;t actually change the index</span>
        <span class="k">if</span> <span class="n">is_copy</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">xs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.</span>
<span class="sd">        Defaults to cross-section on the rows (axis=0).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : object</span>
<span class="sd">            Some label contained in the index, or partially in a MultiIndex</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            Axis to retrieve cross-section on</span>
<span class="sd">        level : object, defaults to first n levels (n=1 or len(key))</span>
<span class="sd">            In case of a key partially contained in a MultiIndex, indicate</span>
<span class="sd">            which levels are used. Levels can be referred by label or position.</span>
<span class="sd">        copy : boolean [deprecated]</span>
<span class="sd">            Whether to make a copy of the data</span>
<span class="sd">        drop_level : boolean, default True</span>
<span class="sd">            If False, returns object with same levels as self.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B  C</span>
<span class="sd">        a  4  5  2</span>
<span class="sd">        b  4  0  9</span>
<span class="sd">        c  9  7  3</span>
<span class="sd">        &gt;&gt;&gt; df.xs(&#39;a&#39;)</span>
<span class="sd">        A    4</span>
<span class="sd">        B    5</span>
<span class="sd">        C    2</span>
<span class="sd">        Name: a</span>
<span class="sd">        &gt;&gt;&gt; df.xs(&#39;C&#39;, axis=1)</span>
<span class="sd">        a    2</span>
<span class="sd">        b    9</span>
<span class="sd">        c    3</span>
<span class="sd">        Name: C</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                            A  B  C  D</span>
<span class="sd">        first second third</span>
<span class="sd">        bar   one    1      4  1  8  9</span>
<span class="sd">              two    1      7  5  5  0</span>
<span class="sd">        baz   one    1      6  6  8  0</span>
<span class="sd">              three  2      5  3  5  3</span>
<span class="sd">        &gt;&gt;&gt; df.xs((&#39;baz&#39;, &#39;three&#39;))</span>
<span class="sd">               A  B  C  D</span>
<span class="sd">        third</span>
<span class="sd">        2      5  3  5  3</span>
<span class="sd">        &gt;&gt;&gt; df.xs(&#39;one&#39;, level=1)</span>
<span class="sd">                     A  B  C  D</span>
<span class="sd">        first third</span>
<span class="sd">        bar   1      4  1  8  9</span>
<span class="sd">        baz   1      6  6  8  0</span>
<span class="sd">        &gt;&gt;&gt; df.xs((&#39;baz&#39;, 2), level=[0, &#39;third&#39;])</span>
<span class="sd">                A  B  C  D</span>
<span class="sd">        second</span>
<span class="sd">        three   5  3  5  3</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xs : Series or DataFrame</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        xs is only for getting, not setting values.</span>

<span class="sd">        MultiIndex Slicers is a generic way to get/set values on any level or levels</span>
<span class="sd">        it is a superset of xs functionality, see :ref:`MultiIndex Slicers &lt;advanced.mi_slicers&gt;`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;copy keyword is deprecated, &quot;</span>
                          <span class="s">&quot;default is to return a copy or a view if possible&quot;</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">new_ax</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">get_loc_level</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                               <span class="n">drop_level</span><span class="o">=</span><span class="n">drop_level</span><span class="p">)</span>

            <span class="c"># convert to a label indexer if needed</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">lev_num</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">labels</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">lev_num</span><span class="p">]</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s">&#39;integer&#39;</span><span class="p">:</span>
                    <span class="n">loc</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

            <span class="c"># create the tuple of the indexer</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">new_ax</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc_level</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                                      <span class="n">drop_level</span><span class="o">=</span><span class="n">drop_level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">loc</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
                    <span class="n">inds</span><span class="p">,</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">fast_xs</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>

            <span class="c"># may need to box a datelike-scalar</span>
            <span class="c">#</span>
            <span class="c"># if we encounter an array-like and we only have 1 dim</span>
            <span class="c"># that means that their are list/ndarrays inside the Series!</span>
            <span class="c"># so just return them (GH 6394)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_maybe_box_datetimelike</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">loc</span><span class="p">],</span>
                            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">new_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">new_index</span>

        <span class="c"># this could be a view</span>
        <span class="c"># but only in a single-dtyped view slicable case</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">_is_view</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">_xs</span> <span class="o">=</span> <span class="n">xs</span>

    <span class="c"># TODO: Check if this was clearer in 0.12</span>
    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return data corresponding to axis labels matching criteria</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crit : function</span>
<span class="sd">            To be called on each index (label). Should return True or False</span>
<span class="sd">        axis : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        selection : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis_values</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">bool</span><span class="p">(</span><span class="n">crit</span><span class="p">(</span><span class="n">label</span><span class="p">))</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">axis_values</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis_values</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">new_axis</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return an object with matching indicies to myself</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Object</span>
<span class="sd">        method : string or None</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            Maximum size gap to forward or backward fill</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Like calling s.reindex(index=other.index, columns=other.columns,</span>
<span class="sd">                               method=...)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reindexed : same as input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s">&#39;raise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new object with labels in requested axis removed</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : single label or list-like</span>
<span class="sd">        axis : int or axis name</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            For MultiIndex</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, do operation inplace and return None.</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;raise&#39;</span>
<span class="sd">            If &#39;ignore&#39;, suppress error and existing labels are dropped.</span>

<span class="sd">            .. versionadded:: 0.16.1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis</span><span class="p">,</span> <span class="n">axis_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">axis</span>

        <span class="k">if</span> <span class="n">axis</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;axis must be a MultiIndex&#39;</span><span class="p">)</span>
                <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
            <span class="n">dropped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">new_axis</span><span class="p">})</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dropped</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis_</span><span class="p">]</span><span class="o">.</span><span class="n">set_names</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dropped</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_index_labels_to_array</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;axis must be a MultiIndex&#39;</span><span class="p">)</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="o">~</span><span class="n">lib</span><span class="o">.</span><span class="n">ismember</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">level</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                        <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="o">~</span><span class="n">axis</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

            <span class="n">slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">slicer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis_name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">indexer</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slicer</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_update_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">verify_is_copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        replace self internals with result.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verify_is_copy : boolean, default True</span>
<span class="sd">            provide is_copy checks</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># NOTE: This does *not* call __finalize__ and that&#39;s an explicit</span>
        <span class="c"># decision that we may revisit in the future.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="s">&#39;_data&#39;</span><span class="p">,</span><span class="n">result</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_update_cacher</span><span class="p">(</span><span class="n">verify_is_copy</span><span class="o">=</span><span class="n">verify_is_copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate prefix string with panel items names.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prefix : string</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        with_prefix : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">add_prefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate suffix string with panel items names</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        suffix : string</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        with_suffix : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">add_suffix</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort object by labels (along an axis)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0, 1}</span>
<span class="sd">            Sort index/rows versus columns</span>
<span class="sd">        ascending : boolean, default True</span>
<span class="sd">            Sort ascending vs. descending</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted_obj : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">sort_index</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
            <span class="n">sort_index</span> <span class="o">=</span> <span class="n">sort_index</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">new_axis</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">sort_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">new_axis</span><span class="p">})</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;reindex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">        Conform </span><span class="si">%(klass)s</span><span class="s"> to new index with optional filling logic, placing</span>
<span class="s">        NA/NaN in locations having no value in the previous index. A new object</span>
<span class="s">        is produced unless the new index is equivalent to the current one and</span>
<span class="s">        copy=False</span>

<span class="s">        Parameters</span>
<span class="s">        ----------</span>
<span class="s">        </span><span class="si">%(axes)s</span><span class="s"> : array-like, optional (can be specified in order, or as</span>
<span class="s">            keywords)</span>
<span class="s">            New labels / index to conform to. Preferably an Index object to</span>
<span class="s">            avoid duplicating data</span>
<span class="s">        method : {None, &#39;backfill&#39;/&#39;bfill&#39;, &#39;pad&#39;/&#39;ffill&#39;, &#39;nearest&#39;}, optional</span>
<span class="s">            Method to use for filling holes in reindexed DataFrame:</span>
<span class="s">              * default: don&#39;t fill gaps</span>
<span class="s">              * pad / ffill: propagate last valid observation forward to next valid</span>
<span class="s">              * backfill / bfill: use next valid observation to fill gap</span>
<span class="s">              * nearest: use nearest valid observations to fill gap</span>
<span class="s">        copy : boolean, default True</span>
<span class="s">            Return a new object, even if the passed indexes are the same</span>
<span class="s">        level : int or name</span>
<span class="s">            Broadcast across a level, matching Index values on the</span>
<span class="s">            passed MultiIndex level</span>
<span class="s">        fill_value : scalar, default np.NaN</span>
<span class="s">            Value to use for missing values. Defaults to NaN, but can be any</span>
<span class="s">            &quot;compatible&quot; value</span>
<span class="s">        limit : int, default None</span>
<span class="s">            Maximum size gap to forward or backward fill</span>

<span class="s">        Examples</span>
<span class="s">        --------</span>
<span class="s">        &gt;&gt;&gt; df.reindex(index=[date1, date2, date3], columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])</span>

<span class="s">        Returns</span>
<span class="s">        -------</span>
<span class="s">        reindexed : </span><span class="si">%(klass)s</span><span class="s"></span>
<span class="s">        &quot;&quot;&quot;</span>
    <span class="c"># TODO: Decide if we care about having different examples for different</span>
    <span class="c">#       kinds</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;reindex&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="s">&quot;axes&quot;</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="s">&quot;NDFrame&quot;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c"># construct the args</span>
        <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_from_arguments</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_clean_reindex_fill_method</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;method&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;level&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;copy&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;limit&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;fill_value&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;reindex() got an unexpected keyword &#39;</span>
                    <span class="s">&#39;argument &quot;{0}&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="c"># if all axes that are requested to reindex are equal, then only copy</span>
        <span class="c"># if indicated must have index names equal here as well as values</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">identical</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c"># check if we are a multi reindex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_reindex_multi</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_multi</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c"># perform the reindex on the axes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_axes</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span>
                                  <span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; perform the reinxed for all the axes &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                <span class="n">labels</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
                <span class="p">{</span><span class="n">axis</span><span class="p">:</span> <span class="p">[</span><span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">]},</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">allow_dups</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_needs_reindex_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; check if we do need a multi reindex &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">com</span><span class="o">.</span><span class="n">_count_not_none</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">method</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">level</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;reindex_axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;Conform input object to new index with optional filling logic,</span>
<span class="sd">        placing NA/NaN in locations having no value in the previous index. A</span>
<span class="sd">        new object is produced unless the new index is equivalent to the</span>
<span class="sd">        current one and copy=False</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : array-like</span>
<span class="sd">            New labels / index to conform to. Preferably an Index object to</span>
<span class="sd">            avoid duplicating data</span>
<span class="sd">        axis : %(axes_single_arg)s</span>
<span class="sd">        method : {None, &#39;backfill&#39;/&#39;bfill&#39;, &#39;pad&#39;/&#39;ffill&#39;, &#39;nearest&#39;}, optional</span>
<span class="sd">            Method to use for filling holes in reindexed DataFrame:</span>
<span class="sd">              * default: don&#39;t fill gaps</span>
<span class="sd">              * pad / ffill: propagate last valid observation forward to next valid</span>
<span class="sd">              * backfill / bfill: use next valid observation to fill gap</span>
<span class="sd">              * nearest: use nearest valid observations to fill gap</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            Return a new object, even if the passed indexes are the same</span>
<span class="sd">        level : int or name</span>
<span class="sd">            Broadcast across a level, matching Index values on the</span>
<span class="sd">            passed MultiIndex level</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            Maximum size gap to forward or backward fill</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df.reindex_axis([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;], axis=1)</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        reindex, reindex_like</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reindexed : %(klass)s</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;reindex_axis&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reindex_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                     <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis_name</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_clean_reindex_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">axis_values</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
                                                 <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
            <span class="p">{</span><span class="n">axis</span><span class="p">:</span> <span class="p">[</span><span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">]},</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_with_indexers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reindexers</span><span class="p">,</span>
                               <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                               <span class="n">allow_dups</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; allow_dups indicates an internal call here &quot;&quot;&quot;</span>

        <span class="c"># reindex doing multiple operations on different axes if indiciated</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">reindexers</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">reindexers</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">baxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">index</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indexer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_ensure_int64</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

            <span class="c"># TODO: speed up on homogeneous DataFrame objects</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">baxis</span><span class="p">,</span>
                                                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                                <span class="n">allow_dups</span><span class="o">=</span><span class="n">allow_dups</span><span class="p">,</span>
                                                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">new_data</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_index</span><span class="p">,</span> <span class="n">fill_method</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                           <span class="n">method</span><span class="o">=</span><span class="n">fill_method</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_data</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">like</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restrict the info axis to set of items or wildcard</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        items : list-like</span>
<span class="sd">            List of info axis to restrict to (must not all be present)</span>
<span class="sd">        like : string</span>
<span class="sd">            Keep info axis where &quot;arg in col == True&quot;</span>
<span class="sd">        regex : string (regular expression)</span>
<span class="sd">            Keep info axis with re.search(regex, col) == True</span>
<span class="sd">        axis : int or None</span>
<span class="sd">            The axis to filter on. By default this is the info axis. The &quot;info</span>
<span class="sd">            axis&quot; is the axis that is used when indexing with ``[]``. For</span>
<span class="sd">            example, ``df = DataFrame({&#39;a&#39;: [1, 2, 3, 4]]}); df[&#39;a&#39;]``. So,</span>
<span class="sd">            the ``DataFrame`` columns are the info axis.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Arguments are mutually exclusive, but this is not checked for</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">re</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">items</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">items</span>
                                               <span class="k">if</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">axis_values</span><span class="p">]})</span>
        <span class="k">elif</span> <span class="n">like</span><span class="p">:</span>
            <span class="n">matchf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">like</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span>
                                <span class="k">else</span> <span class="n">like</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">matchf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">regex</span><span class="p">:</span>
            <span class="n">matcher</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">matcher</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span>
                               <span class="n">axis</span><span class="o">=</span><span class="n">axis_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Must pass either `items`, `like`, or `regex`&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns first n rows</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns last n rows</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span>


    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">frac</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a random sample of items from an axis of object.</span>

<span class="sd">        .. versionadded:: 0.16.1</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, optional</span>
<span class="sd">            Number of items from axis to return. Cannot be used with `frac`.</span>
<span class="sd">            Default = 1 if `frac` = None.</span>
<span class="sd">        frac : float, optional</span>
<span class="sd">            Fraction of axis items to return. Cannot be used with `n`.</span>
<span class="sd">        replace : boolean, optional</span>
<span class="sd">            Sample with or without replacement. Default = False.</span>
<span class="sd">        weights : str or ndarray-like, optional</span>
<span class="sd">            Default &#39;None&#39; results in equal probability weighting.</span>
<span class="sd">            If called on a DataFrame, will accept the name of a column</span>
<span class="sd">            when axis = 0.</span>
<span class="sd">            Weights must be same length as axis being sampled.</span>
<span class="sd">            If weights do not sum to 1, they will be normalized to sum to 1.</span>
<span class="sd">            Missing values in the weights column will be treated as zero.</span>
<span class="sd">            inf and -inf values not allowed.</span>
<span class="sd">        random_state : int or numpy.random.RandomState, optional</span>
<span class="sd">            Seed for the random number generator (if int), or numpy RandomState</span>
<span class="sd">            object.</span>
<span class="sd">        axis : int or string, optional</span>
<span class="sd">            Axis to sample. Accepts axis number or name. Default is stat axis</span>
<span class="sd">            for given data type (0 for Series and DataFrames, 1 for Panels).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Same type as caller.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

        <span class="c"># Process random_state argument</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c"># Check weights for compliance</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>

            <span class="c"># Strings acceptable if a dataframe and axis = 0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">weights</span><span class="p">]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;String passed to weights not a valid column&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Strings can only be passed to weights when sampling from rows on a DataFrame&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Strings cannot be passed as weights when sampling from a Series or Panel.&quot;</span><span class="p">)</span>

            <span class="n">weights</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="n">axis_length</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Weights and axis to be sampled must be of same length&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">weights</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">weights</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;weight vector may not include `inf` values&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">weights</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;weight vector many not include negative values&quot;</span><span class="p">)</span>

            <span class="c"># If has nan, set to zero.</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c"># Renormalize if don&#39;t sum to 1</span>
            <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">values</span>

        <span class="c"># If no frac or n, default to n=1.</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">frac</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">frac</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Only integers accepted as `n` values&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">frac</span> <span class="o">*</span> <span class="n">axis_length</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Please enter a value for `frac` OR `n`, not both&#39;</span><span class="p">)</span>

        <span class="c"># Check for negative sizes</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;A negative number of rows requested. Please provide positive value.&quot;</span><span class="p">)</span>

        <span class="n">locs</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">axis_length</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;pipe&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Apply func(self, *args, **kwargs)</span>

<span class="s">        .. versionadded:: 0.16.2</span>

<span class="s">        Parameters</span>
<span class="s">        ----------</span>
<span class="s">        func : function</span>
<span class="s">            function to apply to the </span><span class="si">%(klass)s</span><span class="s">.</span>
<span class="s">            ``args``, and ``kwargs`` are passed into ``func``.</span>
<span class="s">            Alternatively a ``(callable, data_keyword)`` tuple where</span>
<span class="s">            ``data_keyword`` is a string indicating the keyword of</span>
<span class="s">            ``callable`` that expects the </span><span class="si">%(klass)s</span><span class="s">.</span>
<span class="s">        args : positional arguments passed into ``func``.</span>
<span class="s">        kwargs : a dictionary of keyword arguments passed into ``func``.</span>

<span class="s">        Returns</span>
<span class="s">        -------</span>
<span class="s">        object : the return type of ``func``.</span>

<span class="s">        Notes</span>
<span class="s">        -----</span>

<span class="s">        Use ``.pipe`` when chaining together functions that expect</span>
<span class="s">        on Series or DataFrames. Instead of writing</span>

<span class="s">        &gt;&gt;&gt; f(g(h(df), arg1=a), arg2=b, arg3=c)</span>

<span class="s">        You can write</span>

<span class="s">        &gt;&gt;&gt; (df.pipe(h)</span>
<span class="s">        ...    .pipe(g, arg1=a)</span>
<span class="s">        ...    .pipe(f, arg2=b, arg3=c)</span>
<span class="s">        ... )</span>

<span class="s">        If you have a function that takes the data as (say) the second</span>
<span class="s">        argument, pass a tuple indicating which keyword expects the</span>
<span class="s">        data. For example, suppose ``f`` takes its data as ``arg2``:</span>

<span class="s">        &gt;&gt;&gt; (df.pipe(h)</span>
<span class="s">        ...    .pipe(g, arg1=a)</span>
<span class="s">        ...    .pipe((f, &#39;arg2&#39;), arg1=a, arg3=c)</span>
<span class="s">        ...  )</span>

<span class="s">        See Also</span>
<span class="s">        --------</span>
<span class="s">        pandas.DataFrame.apply</span>
<span class="s">        pandas.DataFrame.applymap</span>
<span class="s">        pandas.Series.map</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;pipe&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">func</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="n">func</span>
            <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> is both the pipe target and a keyword argument&#39;</span> <span class="o">%</span> <span class="n">target</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Attribute access</span>

    <span class="k">def</span> <span class="nf">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        propagate metadata from other to self</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : the object from which to get the attributes that we are going</span>
<span class="sd">            to propagate</span>
<span class="sd">        method : optional, a passed method name ; possibly to take different</span>
<span class="sd">            types of propagation actions based on this</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDFrame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">:</span>
                <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;After regular attribute access, try looking up the name</span>
<span class="sd">        This allows simpler access to columns for interactive use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Note: obj.x will always call obj.__getattribute__(&#39;x&#39;) prior to</span>
        <span class="c"># calling obj.__getattr__(&#39;x&#39;).</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_names_set</span>
                <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span>
                <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accessors</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;&#39;</span><span class="si">%s</span><span class="s">&#39; object has no attribute &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;After regular attribute access, try setting the name</span>
<span class="sd">        This allows simpler access to columns for interactive use.&quot;&quot;&quot;</span>
        <span class="c"># first try regular attribute access via __getattribute__, so that</span>
        <span class="c"># e.g. ``obj.x`` and ``obj.x = 4`` will always reference/modify</span>
        <span class="c"># the same attribute.</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c"># if this fails, go on to more involved attribute setting</span>
        <span class="c"># (note that this matches __getattr__, above).</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_names_set</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">existing</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">existing</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                    <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Getting and setting elements</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Consolidation of internals</span>

    <span class="k">def</span> <span class="nf">_protect_consolidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; consolidate _data. if the blocks have changed, then clear the cache &quot;&quot;&quot;</span>
        <span class="n">blocks_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">!=</span> <span class="n">blocks_before</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_consolidate_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; we are inplace consolidating; return None &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">consolidate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">consolidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute NDFrame with &quot;consolidated&quot; internals (data of each dtype</span>
<span class="sd">        grouped together in a single ndarray). Mainly an internal API function,</span>
<span class="sd">        but available here to the savvy user</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            If False return new object, otherwise modify existing object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        consolidated : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">consolidate</span><span class="p">()</span>
            <span class="n">cons_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">cons_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_mixed_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_mixed_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_numeric_mixed_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_numeric_mixed_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_datelike_mixed_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_datelike_mixed_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_inplace_setting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; check whether we allow in-place setting with this type of value &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric_mixed_type</span><span class="p">:</span>

                <span class="c"># allow an actual np.nan thru</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="k">return</span> <span class="bp">True</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s">&#39;Cannot do inplace boolean setting on mixed-types with a non np.nan value&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_get_numeric_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_numeric_data</span><span class="p">())</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_bool_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_bool_data</span><span class="p">())</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Internal Interface Methods</span>

    <span class="k">def</span> <span class="nf">as_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the frame to its Numpy-array representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        columns: list, optional, default:None</span>
<span class="sd">            If None, return all columns, otherwise, returns specified columns.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : ndarray</span>
<span class="sd">            If the caller is heterogeneous and contains booleans or objects,</span>
<span class="sd">            the result will be of dtype=object. See Notes.</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Return is NOT a Numpy-matrix, rather, a Numpy-array.</span>

<span class="sd">        The dtype will be a lower-common-denominator dtype (implicit</span>
<span class="sd">        upcasting); that is to say if the dtypes (even of numeric types)</span>
<span class="sd">        are mixed, the one that accommodates all will be chosen. Use this</span>
<span class="sd">        with care if you are not dealing with the blocks.</span>

<span class="sd">        e.g. If the dtypes are float16 and float32, dtype will be upcast to</span>
<span class="sd">        float32.  If dtypes are int32 and uint8, dtype will be upcase to</span>
<span class="sd">        int32.</span>

<span class="sd">        This method is provided for backwards compatibility. Generally,</span>
<span class="sd">        it is recommended to use &#39;.values&#39;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Numpy representation of NDFrame</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The dtype will be a lower-common-denominator dtype (implicit</span>
<span class="sd">        upcasting); that is to say if the dtypes (even of numeric types)</span>
<span class="sd">        are mixed, the one that accommodates all will be chosen. Use this</span>
<span class="sd">        with care if you are not dealing with the blocks.</span>

<span class="sd">        e.g. If the dtypes are float16 and float32, dtype will be upcast to</span>
<span class="sd">        float32.  If dtypes are int32 and uint8, dtype will be upcase to</span>
<span class="sd">        int32.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># compat</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; same as values (but handles sparseness conversions) &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_dtype_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the counts of dtypes in this object &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_dtype_counts</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_ftype_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the counts of ftypes in this object &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_ftype_counts</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the dtypes in this object &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_dtypes</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">,</span>
                      <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ftypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ftypes (indication of sparse/dense and dtype)</span>
<span class="sd">        in this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_ftypes</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">,</span>
                      <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the frame to a dict of dtype -&gt; Constructor Types that each has</span>
<span class="sd">        a homogeneous dtype.</span>

<span class="sd">        NOTE: the dtypes of the blocks WILL BE PRESERVED HERE (unlike in</span>
<span class="sd">              as_matrix)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : a dict of dtype -&gt; Constructor Types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="n">bd</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">blocks</span><span class="p">:</span>
            <span class="n">bd</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">blocks</span> <span class="ow">in</span> <span class="n">bd</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c"># Must combine even after consolidation, because there may be</span>
            <span class="c"># sparse items which are never consolidated into one block.</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;Internal property, property synonym for as_blocks()&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_blocks</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">raise_on_error</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast object to input numpy.dtype</span>
<span class="sd">        Return a copy when copy = True (be really careful with this!)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype or Python type</span>
<span class="sd">        raise_on_error : raise on invalid input</span>
<span class="sd">        kwargs : keyword arguments to pass on to the constructor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        casted : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">raise_on_error</span><span class="o">=</span><span class="n">raise_on_error</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of this object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : boolean or string, default True</span>
<span class="sd">            Make a deep copy, i.e. also copy data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        copy : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">convert_dates</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">convert_numeric</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                        <span class="n">convert_timedeltas</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to infer better dtype for object columns</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        convert_dates : boolean, default True</span>
<span class="sd">            If True, convert to date where possible. If &#39;coerce&#39;, force</span>
<span class="sd">            conversion, with unconvertible values becoming NaT.</span>
<span class="sd">        convert_numeric : boolean, default False</span>
<span class="sd">            If True, attempt to coerce to numbers (including strings), with</span>
<span class="sd">            unconvertible values becoming NaN.</span>
<span class="sd">        convert_timedeltas : boolean, default True</span>
<span class="sd">            If True, convert to timedelta where possible. If &#39;coerce&#39;, force</span>
<span class="sd">            conversion, with unconvertible values becoming NaT.</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            If True, return a copy even if no copy is necessary (e.g. no</span>
<span class="sd">            conversion was done). Note: This is meant for internal use, and</span>
<span class="sd">            should not be confused with inplace.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        converted : same as input object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">convert_dates</span><span class="o">=</span><span class="n">convert_dates</span><span class="p">,</span>
                               <span class="n">convert_numeric</span><span class="o">=</span><span class="n">convert_numeric</span><span class="p">,</span>
                               <span class="n">convert_timedeltas</span><span class="o">=</span><span class="n">convert_timedeltas</span><span class="p">,</span>
                               <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">))</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Filling NA&#39;s</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;fillna&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill NA/NaN values using the specified method</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, dict, Series, or DataFrame</span>
<span class="sd">            Value to use to fill holes (e.g. 0), alternately a dict/Series/DataFrame of</span>
<span class="sd">            values specifying which value to use for each index (for a Series) or</span>
<span class="sd">            column (for a DataFrame). (values not in the dict/Series/DataFrame will not be</span>
<span class="sd">            filled). This value cannot be a list.</span>
<span class="sd">        method : {&#39;backfill&#39;, &#39;bfill&#39;, &#39;pad&#39;, &#39;ffill&#39;, None}, default None</span>
<span class="sd">            Method to use for filling holes in reindexed Series</span>
<span class="sd">            pad / ffill: propagate last valid observation forward to next valid</span>
<span class="sd">            backfill / bfill: use NEXT valid observation to fill gap</span>
<span class="sd">        axis : %(axes_single_arg)s</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            If True, fill in place. Note: this will modify any</span>
<span class="sd">            other views on this object, (e.g. a no-copy slice for a column in a</span>
<span class="sd">            DataFrame).</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            If method is specified, this is the maximum number of consecutive</span>
<span class="sd">            NaN values to forward/backward fill. In other words, if there is</span>
<span class="sd">            a gap with more than this number of consecutive NaNs, it will only</span>
<span class="sd">            be partially filled. If method is not specified, this is the</span>
<span class="sd">            maximum number of entries along the entire axis where NaNs will be</span>
<span class="sd">            filled.</span>
<span class="sd">        downcast : dict, default is None</span>
<span class="sd">            a dict of item-&gt;dtype of what to downcast if possible,</span>
<span class="sd">            or the string &#39;infer&#39; which will try to downcast to an appropriate</span>
<span class="sd">            equal type (e.g. float64 to int64 if possible)</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        reindex, asfreq</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filled : %(klass)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;fillna&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
               <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;&quot;value&quot; parameter must be a scalar or dict, but &#39;</span>
                            <span class="s">&#39;you passed a &quot;{0}&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="c"># set the default here, so functions examining the signaure</span>
        <span class="c"># can detect if something was set (e.g. in groupby) (GH9221)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_clean_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;must specify a fill method or value&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                <span class="c"># need to downcast here because of all of the transposes</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">downcast</span><span class="p">()</span>

                <span class="k">return</span> <span class="n">result</span>

            <span class="c"># &gt; 3d</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s">&#39;Cannot fillna with a method for &gt; 3dims&#39;</span>
                <span class="p">)</span>

            <span class="c"># 3d</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

                <span class="c"># fill in 2d chunks</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">col</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">))</span>
                               <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">)])</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="c"># 2d or less</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_clean_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                              <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                              <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                              <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                              <span class="nb">coerce</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                              <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;cannot specify both a fill method and value&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">com</span><span class="o">.</span><span class="n">ABCSeries</span><span class="p">)):</span>
                    <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Series</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">com</span><span class="o">.</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid fill value with a </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                             <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                             <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                             <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">com</span><span class="o">.</span><span class="n">ABCSeries</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Currently only can fill &#39;</span>
                                              <span class="s">&#39;with dict/Series column &#39;</span>
                                              <span class="s">&#39;by column&#39;</span><span class="p">)</span>

                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">com</span><span class="o">.</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                             <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                             <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                             <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notnull</span><span class="p">(),</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid fill value with a </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s">&quot;Synonym for NDFrame.fillna(method=&#39;ffill&#39;)&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;ffill&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                           <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s">&quot;Synonym for NDFrame.fillna(method=&#39;bfill&#39;)&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;bfill&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                           <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_replace</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">regex</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;pad&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace values given in &#39;to_replace&#39; with &#39;value&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_replace : str, regex, list, dict, Series, numeric, or None</span>

<span class="sd">            * str or regex:</span>

<span class="sd">                - str: string exactly matching `to_replace` will be replaced</span>
<span class="sd">                  with `value`</span>
<span class="sd">                - regex: regexs matching `to_replace` will be replaced with</span>
<span class="sd">                  `value`</span>

<span class="sd">            * list of str, regex, or numeric:</span>

<span class="sd">                - First, if `to_replace` and `value` are both lists, they</span>
<span class="sd">                  **must** be the same length.</span>
<span class="sd">                - Second, if ``regex=True`` then all of the strings in **both**</span>
<span class="sd">                  lists will be interpreted as regexs otherwise they will match</span>
<span class="sd">                  directly. This doesn&#39;t matter much for `value` since there</span>
<span class="sd">                  are only a few possible substitution regexes you can use.</span>
<span class="sd">                - str and regex rules apply as above.</span>

<span class="sd">            * dict:</span>

<span class="sd">                - Nested dictionaries, e.g., {&#39;a&#39;: {&#39;b&#39;: nan}}, are read as</span>
<span class="sd">                  follows: look in column &#39;a&#39; for the value &#39;b&#39; and replace it</span>
<span class="sd">                  with nan. You can nest regular expressions as well. Note that</span>
<span class="sd">                  column names (the top-level dictionary keys in a nested</span>
<span class="sd">                  dictionary) **cannot** be regular expressions.</span>
<span class="sd">                - Keys map to column names and values map to substitution</span>
<span class="sd">                  values. You can treat this as a special case of passing two</span>
<span class="sd">                  lists except that you are specifying the column to search in.</span>

<span class="sd">            * None:</span>

<span class="sd">                - This means that the ``regex`` argument must be a string,</span>
<span class="sd">                  compiled regular expression, or list, dict, ndarray or Series</span>
<span class="sd">                  of such elements. If `value` is also ``None`` then this</span>
<span class="sd">                  **must** be a nested dictionary or ``Series``.</span>

<span class="sd">            See the examples section for examples of each of these.</span>
<span class="sd">        value : scalar, dict, list, str, regex, default None</span>
<span class="sd">            Value to use to fill holes (e.g. 0), alternately a dict of values</span>
<span class="sd">            specifying which value to use for each column (columns not in the</span>
<span class="sd">            dict will not be filled). Regular expressions, strings and lists or</span>
<span class="sd">            dicts of such objects are also allowed.</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            If True, in place. Note: this will modify any</span>
<span class="sd">            other views on this object (e.g. a column form a DataFrame).</span>
<span class="sd">            Returns the caller if this is True.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            Maximum size gap to forward or backward fill</span>
<span class="sd">        regex : bool or same types as `to_replace`, default False</span>
<span class="sd">            Whether to interpret `to_replace` and/or `value` as regular</span>
<span class="sd">            expressions. If this is ``True`` then `to_replace` *must* be a</span>
<span class="sd">            string. Otherwise, `to_replace` must be ``None`` because this</span>
<span class="sd">            parameter will be interpreted as a regular expression or a list,</span>
<span class="sd">            dict, or array of regular expressions.</span>
<span class="sd">        method : string, optional, {&#39;pad&#39;, &#39;ffill&#39;, &#39;bfill&#39;}</span>
<span class="sd">            The method to use when for replacement, when ``to_replace`` is a</span>
<span class="sd">            ``list``.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        NDFrame.reindex</span>
<span class="sd">        NDFrame.asfreq</span>
<span class="sd">        NDFrame.fillna</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filled : NDFrame</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            * If `regex` is not a ``bool`` and `to_replace` is not ``None``.</span>
<span class="sd">        TypeError</span>
<span class="sd">            * If `to_replace` is a ``dict`` and `value` is not a ``list``,</span>
<span class="sd">              ``dict``, ``ndarray``, or ``Series``</span>
<span class="sd">            * If `to_replace` is ``None`` and `regex` is not compilable into a</span>
<span class="sd">              regular expression or is a list, dict, ndarray, or Series.</span>
<span class="sd">        ValueError</span>
<span class="sd">            * If `to_replace` and `value` are ``list`` s or ``ndarray`` s, but</span>
<span class="sd">              they are not the same length.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * Regex substitution is performed under the hood with ``re.sub``. The</span>
<span class="sd">          rules for substitution for ``re.sub`` are the same.</span>
<span class="sd">        * Regular expressions will only substitute on strings, meaning you</span>
<span class="sd">          cannot provide, for example, a regular expression matching floating</span>
<span class="sd">          point numbers and expect the columns in your frame that have a</span>
<span class="sd">          numeric dtype to be matched. However, if those floating point numbers</span>
<span class="sd">          *are* strings, then you can do this.</span>
<span class="sd">        * This method has *a lot* of options. You are encouraged to experiment</span>
<span class="sd">          and play with this method to gain intuition about how it works.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">com</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">to_replace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&quot;&#39;to_replace&#39; must be &#39;None&#39; if &#39;regex&#39; is &quot;</span>
                                 <span class="s">&quot;not a bool&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
            <span class="n">warn</span><span class="p">(</span><span class="s">&#39;the &quot;axis&quot; argument is deprecated and will be removed in&#39;</span>
                 <span class="s">&#39;v0.13; this argument has no effect&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># passing a single value that is scalar like</span>
            <span class="c"># when value is None (GH5319), for compat</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dictlike</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dictlike</span><span class="p">(</span><span class="n">regex</span><span class="p">):</span>
                <span class="n">to_replace</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_replace</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">_single_replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_replace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span>
                                       <span class="n">limit</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dictlike</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dictlike</span><span class="p">(</span><span class="n">regex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;If &quot;to_replace&quot; and &quot;value&quot; are both None&#39;</span>
                                    <span class="s">&#39; and &quot;to_replace&quot; is not a list, then &#39;</span>
                                    <span class="s">&#39;regex must be a mapping&#39;</span><span class="p">)</span>
                <span class="n">to_replace</span> <span class="o">=</span> <span class="n">regex</span>
                <span class="n">regex</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">to_replace</span><span class="p">))</span>
            <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">)</span>

            <span class="n">are_mappings</span> <span class="o">=</span> <span class="p">[</span><span class="n">is_dictlike</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">are_mappings</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">are_mappings</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;If a nested mapping is passed, all values&quot;</span>
                                    <span class="s">&quot; of the top level mapping must be &quot;</span>
                                    <span class="s">&quot;mappings&quot;</span><span class="p">)</span>
                <span class="c"># passed a nested dict/Series</span>
                <span class="n">to_rep_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">value_dict</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                    <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Replacement not allowed with &quot;</span>
                                         <span class="s">&quot;overlapping keys and values&quot;</span><span class="p">)</span>
                    <span class="n">to_rep_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
                    <span class="n">value_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

                <span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">to_rep_dict</span><span class="p">,</span> <span class="n">value_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c"># need a non-zero len on all axes</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="bp">self</span>

            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
            <span class="k">if</span> <span class="n">is_dictlike</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_dictlike</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c"># {&#39;A&#39; : NA} -&gt; {&#39;A&#39; : 0}</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">value</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">src</span><span class="p">,</span>
                                                    <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="n">c</span><span class="p">],</span>
                                                    <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                    <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">None</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="n">res</span>

                <span class="c"># {&#39;A&#39;: NA} -&gt; 0</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">com</span><span class="o">.</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">src</span><span class="p">,</span>
                                                        <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                                        <span class="nb">filter</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                                        <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                        <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;value argument must be scalar, dict, or &#39;</span>
                                    <span class="s">&#39;Series&#39;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">com</span><span class="o">.</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>  <span class="c"># [NA, &#39;&#39;] -&gt; [0, &#39;missing&#39;]</span>
                <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Replacement lists must match &#39;</span>
                                         <span class="s">&#39;in length. Expecting </span><span class="si">%d</span><span class="s"> got </span><span class="si">%d</span><span class="s"> &#39;</span> <span class="o">%</span>
                                         <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">to_replace</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">replace_list</span><span class="p">(</span><span class="n">src_list</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
                                                       <span class="n">dest_list</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                                       <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                       <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c"># [NA, &#39;&#39;] -&gt; 0</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
                                                  <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                                  <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                  <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">to_replace</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">is_re_compilable</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="n">com</span><span class="o">.</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="n">is_dictlike</span><span class="p">(</span><span class="n">regex</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;&#39;regex&#39; must be a string or a compiled &quot;</span>
                                    <span class="s">&quot;regular expression or a list or dict of &quot;</span>
                                    <span class="s">&quot;strings or regular expressions, you &quot;</span>
                                    <span class="s">&quot;passed a&quot;</span>
                                    <span class="s">&quot; {0!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                    <span class="n">regex</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c"># dest iterable dict-like</span>
                <span class="k">if</span> <span class="n">is_dictlike</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c"># NA -&gt; {&#39;A&#39; : 0, &#39;B&#39; : -1}</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
                                                        <span class="n">value</span><span class="o">=</span><span class="n">v</span><span class="p">,</span>
                                                        <span class="nb">filter</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                                        <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                        <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>

                <span class="k">elif</span> <span class="ow">not</span> <span class="n">com</span><span class="o">.</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c"># NA -&gt; 0</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                                  <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Invalid &quot;to_replace&quot; type: &#39;</span>
                           <span class="s">&#39;{0!r}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>  <span class="c"># pragma: no cover</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="ow">not</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">convert_numeric</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                    <span class="n">downcast</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate values according to different methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;linear&#39;, &#39;time&#39;, &#39;index&#39;, &#39;values&#39;, &#39;nearest&#39;, &#39;zero&#39;,</span>
<span class="sd">                  &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;barycentric&#39;, &#39;krogh&#39;,</span>
<span class="sd">                  &#39;polynomial&#39;, &#39;spline&#39; &#39;piecewise_polynomial&#39;, &#39;pchip&#39;}</span>

<span class="sd">            * &#39;linear&#39;: ignore the index and treat the values as equally</span>
<span class="sd">              spaced. default</span>
<span class="sd">            * &#39;time&#39;: interpolation works on daily and higher resolution</span>
<span class="sd">              data to interpolate given length of interval</span>
<span class="sd">            * &#39;index&#39;, &#39;values&#39;: use the actual numerical values of the index</span>
<span class="sd">            * &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;,</span>
<span class="sd">              &#39;barycentric&#39;, &#39;polynomial&#39; is passed to</span>
<span class="sd">              `scipy.interpolate.interp1d` with the order given both</span>
<span class="sd">              &#39;polynomial&#39; and &#39;spline&#39; requre that you also specify and order</span>
<span class="sd">              (int) e.g. df.interpolate(method=&#39;polynomial&#39;, order=4)</span>
<span class="sd">            * &#39;krogh&#39;, &#39;piecewise_polynomial&#39;, &#39;spline&#39;, and &#39;pchip&#39; are all</span>
<span class="sd">              wrappers around the scipy interpolation methods of similar</span>
<span class="sd">              names. See the scipy documentation for more on their behavior:</span>
<span class="sd">              http://docs.scipy.org/doc/scipy/reference/interpolate.html#univariate-interpolation</span>
<span class="sd">              http://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html</span>

<span class="sd">        axis : {0, 1}, default 0</span>
<span class="sd">            * 0: fill column-by-column</span>
<span class="sd">            * 1: fill row-by-row</span>
<span class="sd">        limit : int, default None.</span>
<span class="sd">            Maximum number of consecutive NaNs to fill.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Update the NDFrame in place if possible.</span>
<span class="sd">        downcast : optional, &#39;infer&#39; or None, defaults to None</span>
<span class="sd">            Downcast dtypes if possible.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame of same shape interpolated at the NaNs</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        reindex, replace, fillna</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Filling in NaNs</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([0, 1, np.nan, 3])</span>
<span class="sd">        &gt;&gt;&gt; s.interpolate()</span>
<span class="sd">        0    0</span>
<span class="sd">        1    1</span>
<span class="sd">        2    2</span>
<span class="sd">        3    3</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Interpolate has not been implemented &quot;</span>
                                      <span class="s">&quot;on Panel and Panel 4D objects.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">alt_ax</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alt_ax</span> <span class="o">=</span> <span class="n">ax</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s">&#39;linear&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Only `method=linear` interpolation is supported &quot;</span>
                             <span class="s">&quot;on MultiIndexes.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_dtype_counts</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;object&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Cannot interpolate with all NaNs.&quot;</span><span class="p">)</span>

        <span class="c"># create/use the index</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">alt_ax</span><span class="p">)))</span>  <span class="c"># prior default</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">alt_ax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Interpolation with NaNs in the index &quot;</span>
                                      <span class="s">&quot;has not been implemented. Try filling &quot;</span>
                                      <span class="s">&quot;those NaNs before interpolating.&quot;</span><span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                          <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                                          <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                                          <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                          <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                          <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                          <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span>
                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">T</span>
            <span class="k">return</span> <span class="n">res</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Action Methods</span>

    <span class="k">def</span> <span class="nf">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean same-sized object indicating if the values are null</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        notnull : boolean inverse of isnull</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">notnull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a boolean same-sized object indicating if the values are</span>
<span class="sd">        not null</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        isnull : boolean inverse of notnull</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">notnull</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim values at input threshold(s)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lower : float or array_like, default None</span>
<span class="sd">        upper : float or array_like, default None</span>
<span class="sd">        axis : int or string axis name, optional</span>
<span class="sd">            Align object with lower and upper along the given axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clipped : Series</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">          0         1</span>
<span class="sd">        0  0.335232 -1.256177</span>
<span class="sd">        1 -1.367855  0.746646</span>
<span class="sd">        2  0.027753 -1.176076</span>
<span class="sd">        3  0.230930 -0.679613</span>
<span class="sd">        4  1.261967  0.570967</span>
<span class="sd">        &gt;&gt;&gt; df.clip(-1.0, 0.5)</span>
<span class="sd">                  0         1</span>
<span class="sd">        0  0.335232 -1.000000</span>
<span class="sd">        1 -1.000000  0.500000</span>
<span class="sd">        2  0.027753 -1.000000</span>
<span class="sd">        3  0.230930 -0.679613</span>
<span class="sd">        4  0.500000  0.500000</span>
<span class="sd">        &gt;&gt;&gt; t</span>
<span class="sd">        0   -0.3</span>
<span class="sd">        1   -0.2</span>
<span class="sd">        2   -0.1</span>
<span class="sd">        3    0.0</span>
<span class="sd">        4    0.1</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; df.clip(t, t + 1, axis=0)</span>
<span class="sd">                  0         1</span>
<span class="sd">        0  0.335232 -0.300000</span>
<span class="sd">        1 -0.200000  0.746646</span>
<span class="sd">        2  0.027753 -0.100000</span>
<span class="sd">        3  0.230930  0.000000</span>
<span class="sd">        4  1.100000  0.570967</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>  <span class="c"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;out argument is not supported yet&#39;</span><span class="p">)</span>

        <span class="c"># GH 2747 (arguments were reversed)</span>
        <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lib</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lib</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">upper</span><span class="p">):</span>
                <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">clip_lower</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">clip_upper</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">clip_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return copy of input with values above given value(s) truncated</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : float or array_like</span>
<span class="sd">        axis : int or string axis name, optional</span>
<span class="sd">            Align object with threshold along the given axis.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        clip</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clipped : same type as input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isnull</span><span class="p">(</span><span class="n">threshold</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot use an NA value as a clip threshold&quot;</span><span class="p">)</span>

        <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">|</span> <span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clip_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return copy of the input with values below given value(s) truncated</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : float or array_like</span>
<span class="sd">        axis : int or string axis name, optional</span>
<span class="sd">            Align object with threshold along the given axis.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        clip</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clipped : same type as input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isnull</span><span class="p">(</span><span class="n">threshold</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot use an NA value as a clip threshold&quot;</span><span class="p">)</span>

        <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">|</span> <span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                <span class="n">group_keys</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Group series using mapper (dict or key function, apply given function</span>
<span class="sd">        to group, return result as series) or by a series of columns</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        by : mapping function / list of functions, dict, Series, or tuple /</span>
<span class="sd">            list of column names.</span>
<span class="sd">            Called on each element of the object index to determine the groups.</span>
<span class="sd">            If a dict or Series is passed, the Series or dict VALUES will be</span>
<span class="sd">            used to determine the groups</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">        level : int, level name, or sequence of such, default None</span>
<span class="sd">            If the axis is a MultiIndex (hierarchical), group by a particular</span>
<span class="sd">            level or levels</span>
<span class="sd">        as_index : boolean, default True</span>
<span class="sd">            For aggregated output, return object with group labels as the</span>
<span class="sd">            index. Only relevant for DataFrame input. as_index=False is</span>
<span class="sd">            effectively &quot;SQL-style&quot; grouped output</span>
<span class="sd">        sort : boolean, default True</span>
<span class="sd">            Sort group keys. Get better performance by turning this off</span>
<span class="sd">        group_keys : boolean, default True</span>
<span class="sd">            When calling apply, add group keys to index to identify pieces</span>
<span class="sd">        squeeze : boolean, default False</span>
<span class="sd">            reduce the dimensionaility of the return type if possible,</span>
<span class="sd">            otherwise return a consistent type</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame results</span>

<span class="sd">        &gt;&gt;&gt; data.groupby(func, axis=0).mean()</span>
<span class="sd">        &gt;&gt;&gt; data.groupby([&#39;col1&#39;, &#39;col2&#39;])[&#39;col3&#39;].mean()</span>

<span class="sd">        DataFrame with hierarchical index</span>

<span class="sd">        &gt;&gt;&gt; data.groupby([&#39;col1&#39;, &#39;col2&#39;]).mean()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GroupBy object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.groupby</span> <span class="kn">import</span> <span class="n">groupby</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">by</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;You have to supply one of &#39;by&#39; and &#39;level&#39;&quot;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="n">by</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="n">as_index</span><span class="p">,</span>
                       <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="n">group_keys</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="n">squeeze</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">asfreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert all TimeSeries inside to specified frequency using DateOffset</span>
<span class="sd">        objects. Optionally provide fill method to pad/backfill missing values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : DateOffset object, or string</span>
<span class="sd">        method : {&#39;backfill&#39;, &#39;bfill&#39;, &#39;pad&#39;, &#39;ffill&#39;, None}</span>
<span class="sd">            Method to use for filling holes in reindexed Series</span>
<span class="sd">            pad / ffill: propagate last valid observation forward to next valid</span>
<span class="sd">            backfill / bfill: use NEXT valid observation to fill method</span>
<span class="sd">        how : {&#39;start&#39;, &#39;end&#39;}, default end</span>
<span class="sd">            For PeriodIndex only, see PeriodIndex.asfreq</span>
<span class="sd">        normalize : bool, default False</span>
<span class="sd">            Whether to reset output index to midnight</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        converted : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.tseries.resample</span> <span class="kn">import</span> <span class="n">asfreq</span>
        <span class="k">return</span> <span class="n">asfreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                      <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">at_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">asof</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select values at particular time of day (e.g. 9:30AM)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : datetime.time or string</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values_at_time : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">indexer_at_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">asof</span><span class="o">=</span><span class="n">asof</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Index must be DatetimeIndex&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">between_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">include_start</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                     <span class="n">include_end</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select values between particular times of the day (e.g., 9:00-9:30 AM)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_time : datetime.time or string</span>
<span class="sd">        end_time : datetime.time or string</span>
<span class="sd">        include_start : boolean, default True</span>
<span class="sd">        include_end : boolean, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values_between_time : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">indexer_between_time</span><span class="p">(</span>
                <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">include_start</span><span class="o">=</span><span class="n">include_start</span><span class="p">,</span>
                <span class="n">include_end</span><span class="o">=</span><span class="n">include_end</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Index must be DatetimeIndex&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">closed</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="s">&#39;start&#39;</span><span class="p">,</span>
                 <span class="n">kind</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">loffset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method for frequency conversion and resampling of regular</span>
<span class="sd">        time-series data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rule : string</span>
<span class="sd">            the offset string or object representing target conversion</span>
<span class="sd">        how : string</span>
<span class="sd">            method for down- or re-sampling, default to &#39;mean&#39; for</span>
<span class="sd">            downsampling</span>
<span class="sd">        axis : int, optional, default 0</span>
<span class="sd">        fill_method : string, default None</span>
<span class="sd">            fill_method for upsampling</span>
<span class="sd">        closed : {&#39;right&#39;, &#39;left&#39;}</span>
<span class="sd">            Which side of bin interval is closed</span>
<span class="sd">        label : {&#39;right&#39;, &#39;left&#39;}</span>
<span class="sd">            Which bin edge label to label bucket with</span>
<span class="sd">        convention : {&#39;start&#39;, &#39;end&#39;, &#39;s&#39;, &#39;e&#39;}</span>
<span class="sd">        kind : &quot;period&quot;/&quot;timestamp&quot;</span>
<span class="sd">        loffset : timedelta</span>
<span class="sd">            Adjust the resampled time labels</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            Maximum size gap to when reindexing with fill_method</span>
<span class="sd">        base : int, default 0</span>
<span class="sd">            For frequencies that evenly subdivide 1 day, the &quot;origin&quot; of the</span>
<span class="sd">            aggregated intervals. For example, for &#39;5min&#39; frequency, base could</span>
<span class="sd">            range from 0 through 4. Defaults to 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.tseries.resample</span> <span class="kn">import</span> <span class="n">TimeGrouper</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">sampler</span> <span class="o">=</span> <span class="n">TimeGrouper</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                              <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">loffset</span><span class="o">=</span><span class="n">loffset</span><span class="p">,</span>
                              <span class="n">fill_method</span><span class="o">=</span><span class="n">fill_method</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="n">convention</span><span class="p">,</span>
                              <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sampler</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method for subsetting initial periods of time series data</span>
<span class="sd">        based on a date offset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset : string, DateOffset, dateutil.relativedelta</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ts.last(&#39;10D&#39;) -&gt; First 10 days</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subset : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.tseries.frequencies</span> <span class="kn">import</span> <span class="n">to_offset</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;&#39;first&#39; only supports a DatetimeIndex &quot;</span>
                                      <span class="s">&quot;index&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="c"># Tick-like, e.g. 3 weeks</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">offset</span><span class="o">.</span><span class="n">isAnchored</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="s">&#39;_inc&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">end_date</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">end_date</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method for subsetting final periods of time series data</span>
<span class="sd">        based on a date offset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset : string, DateOffset, dateutil.relativedelta</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ts.last(&#39;5M&#39;) -&gt; Last 5 months</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subset : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.tseries.frequencies</span> <span class="kn">import</span> <span class="n">to_offset</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;&#39;last&#39; only supports a DatetimeIndex &quot;</span>
                                      <span class="s">&quot;index&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="n">start_date</span> <span class="o">=</span> <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">start</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s">&#39;outer&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
              <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Align two object on their axes with the</span>
<span class="sd">        specified join method for each axis Index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame or Series</span>
<span class="sd">        join : {&#39;outer&#39;, &#39;inner&#39;, &#39;left&#39;, &#39;right&#39;}, default &#39;outer&#39;</span>
<span class="sd">        axis : allowed axis of the other object, default None</span>
<span class="sd">            Align on index (0), columns (1), or both (None)</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            Broadcast across a level, matching Index values on the</span>
<span class="sd">            passed MultiIndex level</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            Always returns new objects. If copy=False and no reindexing is</span>
<span class="sd">            required then original objects are returned.</span>
<span class="sd">        fill_value : scalar, default np.NaN</span>
<span class="sd">            Value to use for missing values. Defaults to NaN, but can be any</span>
<span class="sd">            &quot;compatible&quot; value</span>
<span class="sd">        method : str, default None</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">        fill_axis : {0, 1}, default 0</span>
<span class="sd">            Filling axis, method and limit</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (left, right) : (type of input, type of other)</span>
<span class="sd">            Aligned objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_clean_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_frame</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                     <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                     <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                     <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_series</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                      <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                      <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                      <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;unsupported type: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_align_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s">&#39;outer&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">fill_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c"># defaults</span>
        <span class="n">join_index</span><span class="p">,</span> <span class="n">join_columns</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="n">ilidx</span><span class="p">,</span> <span class="n">iridx</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="n">clidx</span><span class="p">,</span> <span class="n">cridx</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">ilidx</span><span class="p">,</span> <span class="n">iridx</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                    <span class="n">return_indexers</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="n">join_columns</span><span class="p">,</span> <span class="n">clidx</span><span class="p">,</span> <span class="n">cridx</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                      <span class="n">return_indexers</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">join_index</span><span class="p">,</span>   <span class="n">ilidx</span><span class="p">],</span>
                                            <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">join_columns</span><span class="p">,</span> <span class="n">clidx</span><span class="p">]},</span>
                                           <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                           <span class="n">allow_dups</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">join_index</span><span class="p">,</span>   <span class="n">iridx</span><span class="p">],</span>
                                              <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">join_columns</span><span class="p">,</span> <span class="n">cridx</span><span class="p">]},</span>
                                             <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                             <span class="n">allow_dups</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">right</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_align_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s">&#39;outer&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                      <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                      <span class="n">fill_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>

        <span class="c"># series/series compat</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;cannot align series to a series other than &#39;</span>
                                 <span class="s">&#39;axis 0&#39;</span><span class="p">)</span>

            <span class="c"># equal</span>
            <span class="k">if</span>  <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
                                                         <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                                         <span class="n">return_indexers</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">ridx</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c"># one has &gt; 1 ndim</span>
            <span class="n">fdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
                <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                    <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                        <span class="n">return_indexers</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">lidx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">fdata</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
                <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                    <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                          <span class="n">return_indexers</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">lidx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">fdata</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Must specify axis=0 or 1&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">fdata</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="n">fdata</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">left</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">fdata</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ridx</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">other</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>

        <span class="c"># fill</span>
        <span class="n">fill_na</span> <span class="o">=</span> <span class="n">notnull</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fill_na</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">right</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;where&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Return an object of same shape as self and whose corresponding</span>
<span class="s">        entries are from self where cond is </span><span class="si">%(cond)s</span><span class="s"> and otherwise are from other.</span>

<span class="s">        Parameters</span>
<span class="s">        ----------</span>
<span class="s">        cond : boolean </span><span class="si">%(klass)s</span><span class="s"> or array</span>
<span class="s">        other : scalar or </span><span class="si">%(klass)s</span><span class="s"></span>
<span class="s">        inplace : boolean, default False</span>
<span class="s">            Whether to perform the operation in place on the data</span>
<span class="s">        axis : alignment axis if needed, default None</span>
<span class="s">        level : alignment level if needed, default None</span>
<span class="s">        try_cast : boolean, default False</span>
<span class="s">            try to cast the result back to the input type (if possible),</span>
<span class="s">        raise_on_error : boolean, default True</span>
<span class="s">            Whether to raise on invalid data types (e.g. trying to where on</span>
<span class="s">            strings)</span>

<span class="s">        Returns</span>
<span class="s">        -------</span>
<span class="s">        wh : same type as caller</span>
<span class="s">        &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;where&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_shared_doc_kwargs</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="s">&quot;True&quot;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
              <span class="n">try_cast</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">raise_on_error</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">NDFrame</span><span class="p">):</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="s">&#39;shape&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;where requires an ndarray like object for &#39;</span>
                                 <span class="s">&#39;its condition&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&#39;Array conditional must be same shape as self&#39;</span><span class="p">)</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">cond</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c"># try to align</span>
        <span class="n">try_quick</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s">&#39;align&#39;</span><span class="p">):</span>

            <span class="c"># align with me</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>

                <span class="n">_</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">,</span>
                                      <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                      <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

                <span class="c"># if we are NOT aligned, raise as we cannot where index</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)])):</span>
                    <span class="k">raise</span> <span class="n">InvalidIndexError</span>

            <span class="c"># slice me out of the other</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">(</span>
                    <span class="s">&quot;cannot align with a higher dimensional NDFrame&quot;</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                <span class="c"># try to set the same dtype as ourselves</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">new_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">new_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

                <span class="n">matches</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_other</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">matches</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">matches</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>

                    <span class="c"># coerce other to a common dtype if we can</span>
                    <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">needs_i8_conversion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                        <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">common_type</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">new_other</span><span class="p">))</span>

                    <span class="c"># we need to use the new dtype</span>
                    <span class="n">try_quick</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">new_other</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                    <span class="n">icond</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">values</span>

                    <span class="c"># GH 2745 / GH 4192</span>
                    <span class="c"># treat like a scalar</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c"># GH 3235</span>
                    <span class="c"># match True cond to other</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">cond</span><span class="p">[</span><span class="n">icond</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>

                        <span class="c"># try to not change dtype at first (if try_quick)</span>
                        <span class="k">if</span> <span class="n">try_quick</span><span class="p">:</span>

                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">new_other</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                                <span class="n">new_other</span><span class="p">[</span><span class="n">icond</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span>
                                <span class="n">other</span> <span class="o">=</span> <span class="n">new_other</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="n">try_quick</span> <span class="o">=</span> <span class="bp">False</span>

                        <span class="c"># let&#39;s create a new (if we failed at the above</span>
                        <span class="c"># or not try_quick</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">try_quick</span><span class="p">:</span>

                            <span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_maybe_promote</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                            <span class="n">new_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">icond</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                            <span class="n">new_other</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
                            <span class="n">com</span><span class="o">.</span><span class="n">_maybe_upcast_putmask</span><span class="p">(</span><span class="n">new_other</span><span class="p">,</span> <span class="n">icond</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                            <span class="n">other</span> <span class="o">=</span> <span class="n">new_other</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s">&#39;Length of replacements must equal series length&#39;</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;other must be the same shape as self &#39;</span>
                                     <span class="s">&#39;when an ndarray&#39;</span><span class="p">)</span>

            <span class="c"># we are the same shape, so create an actual object for alignment</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c"># we may have different type blocks come out of putmask, so</span>
            <span class="c"># reconstruct the block manager</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_inplace_setting</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">,</span>
                                          <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">,</span>
                                        <span class="n">raise_on_error</span><span class="o">=</span><span class="n">raise_on_error</span><span class="p">,</span>
                                        <span class="n">try_cast</span><span class="o">=</span><span class="n">try_cast</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;where&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_shared_doc_kwargs</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="s">&quot;False&quot;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">try_cast</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">raise_on_error</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">try_cast</span><span class="o">=</span><span class="n">try_cast</span><span class="p">,</span> <span class="n">raise_on_error</span><span class="o">=</span><span class="n">raise_on_error</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;shift&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Shift index by desired number of periods with an optional time freq</span>

<span class="s">        Parameters</span>
<span class="s">        ----------</span>
<span class="s">        periods : int</span>
<span class="s">            Number of periods to move, can be positive or negative</span>
<span class="s">        freq : DateOffset, timedelta, or time rule string, optional</span>
<span class="s">            Increment to use from datetools module or time rule (e.g. &#39;EOM&#39;).</span>
<span class="s">            See Notes.</span>
<span class="s">        axis : </span><span class="si">%(axes_single_arg)s</span><span class="s"></span>

<span class="s">        Notes</span>
<span class="s">        -----</span>
<span class="s">        If freq is specified then the index values are shifted but the data</span>
<span class="s">        is not realigned. That is, use freq if you would like to extend the</span>
<span class="s">        index when shifting and preserve the original data.</span>

<span class="s">        Returns</span>
<span class="s">        -------</span>
<span class="s">        shifted : </span><span class="si">%(klass)s</span><span class="s"></span>
<span class="s">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;shift&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">block_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">block_axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tshift</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">slice_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equivalent to `shift` without copying data. The shifted data will</span>
<span class="sd">        not include the dropped periods and the shifted axis will be smaller</span>
<span class="sd">        than the original.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int</span>
<span class="sd">            Number of periods to move, can be positive or negative</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        While the `slice_shift` is faster than `shift`, you may pay for it</span>
<span class="sd">        later during alignment.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted : same type as caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">periods</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vslicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="o">-</span><span class="n">periods</span><span class="p">)</span>
            <span class="n">islicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vslicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">periods</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">islicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">periods</span><span class="p">)</span>

        <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">(</span><span class="n">vslicer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">shifted_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)[</span><span class="n">islicer</span><span class="p">]</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">shifted_axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift the time index, using the index&#39;s frequency if available</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int</span>
<span class="sd">            Number of periods to move, can be positive or negative</span>
<span class="sd">        freq : DateOffset, timedelta, or time rule string, default None</span>
<span class="sd">            Increment to use from datetools module or time rule (e.g. &#39;EOM&#39;)</span>
<span class="sd">        axis : int or basestring</span>
<span class="sd">            Corresponds to the axis that contains the Index</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If freq is not specified then tries to use the freq or inferred_freq</span>
<span class="sd">        attributes of the index. If neither of those attributes exist, a</span>
<span class="sd">        ValueError is thrown</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted : NDFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.datetools</span> <span class="kn">import</span> <span class="n">_resolve_offset</span>

        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s">&#39;freq&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s">&#39;inferred_freq&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Freq was not given and was not set in the index&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">_resolve_offset</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">datetools</span><span class="o">.</span><span class="n">to_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="n">block_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">):</span>
            <span class="n">orig_offset</span> <span class="o">=</span> <span class="n">datetools</span><span class="o">.</span><span class="n">to_offset</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="o">==</span> <span class="n">orig_offset</span><span class="p">:</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">block_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Given freq </span><span class="si">%s</span><span class="s"> does not match PeriodIndex freq </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                       <span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">rule_code</span><span class="p">,</span> <span class="n">orig_offset</span><span class="o">.</span><span class="n">rule_code</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">block_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Truncates a sorted NDFrame before and/or after some particular</span>
<span class="sd">        dates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        before : date</span>
<span class="sd">            Truncate before date</span>
<span class="sd">        after : date</span>
<span class="sd">            Truncate after date</span>
<span class="sd">        axis : the truncation axis, defaults to the stat axis</span>
<span class="sd">        copy : boolean, default is True,</span>
<span class="sd">            return a copy of the truncated section</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        truncated : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c"># if we have a date index, convert to dates, otherwise</span>
        <span class="c"># treat like a slice</span>
        <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">is_all_dates</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas.tseries.tools</span> <span class="kn">import</span> <span class="n">to_datetime</span>
            <span class="n">before</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">before</span><span class="p">)</span>
            <span class="n">after</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">before</span> <span class="o">&gt;</span> <span class="n">after</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Truncate: </span><span class="si">%s</span><span class="s"> must be after </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">after</span><span class="p">,</span> <span class="n">before</span><span class="p">))</span>

        <span class="n">slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span>
        <span class="n">slicer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slicer</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert tz-aware axis to target time zone.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : string or pytz.timezone object</span>
<span class="sd">        axis : the axis to convert</span>
<span class="sd">        level : int, str, default None</span>
<span class="sd">            If axis ia a MultiIndex, convert a specific level. Otherwise</span>
<span class="sd">            must be None</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            Also make a copy of the underlying data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the axis is tz-naive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_tz_convert</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s">&#39;tz_convert&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ax_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is not a valid DatetimeIndex or PeriodIndex&#39;</span> <span class="o">%</span>
                                    <span class="n">ax_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">([],</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ax</span>

        <span class="c"># if a level is given it must be a MultiIndex level or</span>
        <span class="c"># equivalent to the axis name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">new_level</span> <span class="o">=</span> <span class="n">_tz_convert</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">tz</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_levels</span><span class="p">(</span><span class="n">new_level</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The level {0} is not valid&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span>  <span class="n">_tz_convert</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@deprecate_kwarg</span><span class="p">(</span><span class="n">old_arg_name</span><span class="o">=</span><span class="s">&#39;infer_dst&#39;</span><span class="p">,</span> <span class="n">new_arg_name</span><span class="o">=</span><span class="s">&#39;ambiguous&#39;</span><span class="p">,</span>
                     <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="bp">True</span><span class="p">:</span> <span class="s">&#39;infer&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">:</span> <span class="s">&#39;raise&#39;</span><span class="p">})</span>
    <span class="k">def</span> <span class="nf">tz_localize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                    <span class="n">ambiguous</span><span class="o">=</span><span class="s">&#39;raise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Localize tz-naive TimeSeries to target time zone</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : string or pytz.timezone object</span>
<span class="sd">        axis : the axis to localize</span>
<span class="sd">        level : int, str, default None</span>
<span class="sd">            If axis ia a MultiIndex, localize a specific level. Otherwise</span>
<span class="sd">            must be None</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            Also make a copy of the underlying data</span>
<span class="sd">        ambiguous : &#39;infer&#39;, bool-ndarray, &#39;NaT&#39;, default &#39;raise&#39;</span>
<span class="sd">            - &#39;infer&#39; will attempt to infer fall dst-transition hours based on order</span>
<span class="sd">            - bool-ndarray where True signifies a DST time, False designates</span>
<span class="sd">              a non-DST time (note that this flag is only applicable for ambiguous times)</span>
<span class="sd">            - &#39;NaT&#39; will return NaT where there are ambiguous times</span>
<span class="sd">            - &#39;raise&#39; will raise an AmbiguousTimeError if there are ambiguous times</span>
<span class="sd">        infer_dst : boolean, default False (DEPRECATED)</span>
<span class="sd">            Attempt to infer fall dst-transition hours based on order</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the TimeSeries is tz-aware and tz is not None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_tz_localize</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s">&#39;tz_localize&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ax_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> is not a valid DatetimeIndex or PeriodIndex&#39;</span> <span class="o">%</span>
                                    <span class="n">ax_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">([],</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="o">=</span><span class="n">ambiguous</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ax</span>

        <span class="c"># if a level is given it must be a MultiIndex level or</span>
        <span class="c"># equivalent to the axis name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">new_level</span> <span class="o">=</span> <span class="n">_tz_localize</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_levels</span><span class="p">(</span><span class="n">new_level</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The level {0} is not valid&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span>  <span class="n">_tz_localize</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Numeric Methods</span>
    <span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an object with absolute value taken. Only applicable to objects</span>
<span class="sd">        that are all numeric</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        abs: type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;describe&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">        Generate various summary statistics, excluding NaN values.</span>

<span class="s">        Parameters</span>
<span class="s">        ----------</span>
<span class="s">        percentile_width : float, deprecated</span>
<span class="s">            The ``percentile_width`` argument will be removed in a future</span>
<span class="s">            version. Use ``percentiles`` instead.</span>
<span class="s">            width of the desired uncertainty interval, default is 50,</span>
<span class="s">            which corresponds to lower=25, upper=75</span>
<span class="s">        percentiles : array-like, optional</span>
<span class="s">            The percentiles to include in the output. Should all</span>
<span class="s">            be in the interval [0, 1]. By default `percentiles` is</span>
<span class="s">            [.25, .5, .75], returning the 25th, 50th, and 75th percentiles.</span>
<span class="s">        include, exclude : list-like, &#39;all&#39;, or None (default)</span>
<span class="s">            Specify the form of the returned result. Either:</span>

<span class="s">            - None to both (default). The result will include only numeric-typed</span>
<span class="s">              columns or, if none are, only categorical columns.</span>
<span class="s">            - A list of dtypes or strings to be included/excluded.</span>
<span class="s">              To select all numeric types use numpy numpy.number. To select</span>
<span class="s">              categorical objects use type object. See also the select_dtypes</span>
<span class="s">              documentation. eg. df.describe(include=[&#39;O&#39;])</span>
<span class="s">            - If include is the string &#39;all&#39;, the output column-set will</span>
<span class="s">              match the input one.</span>

<span class="s">        Returns</span>
<span class="s">        -------</span>
<span class="s">        summary: </span><span class="si">%(klass)s</span><span class="s"> of summary statistics</span>

<span class="s">        Notes</span>
<span class="s">        -----</span>
<span class="s">        The output DataFrame index depends on the requested dtypes:</span>

<span class="s">        For numeric dtypes, it will include: count, mean, std, min,</span>
<span class="s">        max, and lower, 50, and upper percentiles.</span>

<span class="s">        For object dtypes (e.g. timestamps or strings), the index</span>
<span class="s">        will include the count, unique, most common, and frequency of the</span>
<span class="s">        most common. Timestamps also include the first and last items.</span>

<span class="s">        For mixed dtypes, the index will be the union of the corresponding</span>
<span class="s">        output types. Non-applicable entries will be filled with NaN.</span>
<span class="s">        Note that mixed-dtype outputs can only be returned from mixed-dtype</span>
<span class="s">        inputs and appropriate use of the include/exclude arguments.</span>

<span class="s">        If multiple values have the highest count, then the</span>
<span class="s">        `count` and `most common` pair will be arbitrarily chosen from</span>
<span class="s">        among those with the highest count.</span>

<span class="s">        The include, exclude arguments are ignored for Series.</span>

<span class="s">        See also</span>
<span class="s">        --------</span>
<span class="s">        DataFrame.select_dtypes</span>
<span class="s">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;describe&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentile_width</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">percentiles</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="bp">None</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;describe is not implemented on on Panel or PanelND objects.&quot;</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">percentile_width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">percentiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Cannot specify both &#39;percentile_width&#39; and &#39;percentiles.&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">percentiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># get them all to be in [0, 1]</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">percentiles</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">percentiles</span> <span class="o">=</span> <span class="n">percentiles</span> <span class="o">/</span> <span class="mf">100.0</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;percentiles should all be in the interval [0, 1]. &quot;</span>
                       <span class="s">&quot;Try {0} instead.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># only warn if they change the default</span>
            <span class="k">if</span> <span class="n">percentile_width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">do_warn</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">do_warn</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">percentile_width</span> <span class="o">=</span> <span class="n">percentile_width</span> <span class="ow">or</span> <span class="mi">50</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">percentile_width</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">)</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">lb</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lb</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ub</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">do_warn</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;The `percentile_width` keyword is deprecated. &quot;</span>
                       <span class="s">&quot;Use percentiles={0} instead&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>

        <span class="c"># median should always be included</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">percentiles</span> <span class="o">!=</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>  <span class="c"># median isn&#39;t included</span>
            <span class="n">lh</span> <span class="o">=</span> <span class="n">percentiles</span><span class="p">[</span><span class="n">percentiles</span> <span class="o">&lt;</span> <span class="o">.</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">uh</span> <span class="o">=</span> <span class="n">percentiles</span><span class="p">[</span><span class="n">percentiles</span> <span class="o">&gt;</span> <span class="o">.</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">lh</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">uh</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">pretty_name</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">*=</span> <span class="mi">100</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="s">&#39;</span><span class="si">%.0f%%</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">x</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&#39;</span><span class="si">%.1f%%</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">x</span>

        <span class="k">def</span> <span class="nf">describe_numeric_1d</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">percentiles</span><span class="p">):</span>
            <span class="n">stat_index</span> <span class="o">=</span> <span class="p">([</span><span class="s">&#39;count&#39;</span><span class="p">,</span> <span class="s">&#39;mean&#39;</span><span class="p">,</span> <span class="s">&#39;std&#39;</span><span class="p">,</span> <span class="s">&#39;min&#39;</span><span class="p">]</span> <span class="o">+</span>
                  <span class="p">[</span><span class="n">pretty_name</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">percentiles</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s">&#39;max&#39;</span><span class="p">])</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">([</span><span class="n">series</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">series</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">series</span><span class="o">.</span><span class="n">std</span><span class="p">(),</span> <span class="n">series</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span> <span class="o">+</span>
                 <span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">percentiles</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">stat_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">series</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>


        <span class="k">def</span> <span class="nf">describe_categorical_1d</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;count&#39;</span><span class="p">,</span> <span class="s">&#39;unique&#39;</span><span class="p">]</span>
            <span class="n">objcounts</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">objcounts</span><span class="p">[</span><span class="n">objcounts</span><span class="o">!=</span><span class="mi">0</span><span class="p">])]</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">top</span><span class="p">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">objcounts</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">objcounts</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span> <span class="ow">or</span> <span class="n">com</span><span class="o">.</span><span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                    <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="s">&#39;top&#39;</span><span class="p">,</span> <span class="s">&#39;freq&#39;</span><span class="p">]</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="p">[</span><span class="n">top</span><span class="p">,</span> <span class="n">freq</span><span class="p">]</span>

                <span class="k">elif</span> <span class="n">com</span><span class="o">.</span><span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                    <span class="n">asint</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s">&#39;i8&#39;</span><span class="p">)</span>
                    <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="s">&#39;top&#39;</span><span class="p">,</span> <span class="s">&#39;freq&#39;</span><span class="p">,</span> <span class="s">&#39;first&#39;</span><span class="p">,</span> <span class="s">&#39;last&#39;</span><span class="p">]</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">top</span><span class="p">),</span> <span class="n">freq</span><span class="p">,</span>
                               <span class="n">lib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">asint</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>
                               <span class="n">lib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">asint</span><span class="o">.</span><span class="n">max</span><span class="p">())]</span>

            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">describe_1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">percentiles</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">describe_numeric_1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">percentiles</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">com</span><span class="o">.</span><span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">describe_numeric_1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">percentiles</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">describe_categorical_1d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">describe_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentiles</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">include</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">exclude</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># when some numerics are found, keep only numerics</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">include</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exclude</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;exclude must be None when include is &#39;all&#39;&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="n">include</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>

        <span class="n">ldesc</span> <span class="o">=</span> <span class="p">[</span><span class="n">describe_1d</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">percentiles</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>
        <span class="c"># set a convenient order for rows</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ldesc_indexes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ldesc</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idxnames</span> <span class="ow">in</span> <span class="n">ldesc_indexes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">idxnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">ldesc</span><span class="p">,</span> <span class="n">join_axes</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="n">names</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;pct_change&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">        Percent change over given number of periods.</span>

<span class="s">        Parameters</span>
<span class="s">        ----------</span>
<span class="s">        periods : int, default 1</span>
<span class="s">            Periods to shift for forming percent change</span>
<span class="s">        fill_method : str, default &#39;pad&#39;</span>
<span class="s">            How to handle NAs before computing percent changes</span>
<span class="s">        limit : int, default None</span>
<span class="s">            The number of consecutive NAs to fill before stopping</span>
<span class="s">        freq : DateOffset, timedelta, or offset alias string, optional</span>
<span class="s">            Increment to use from time series API (e.g. &#39;M&#39; or BDay())</span>

<span class="s">        Returns</span>
<span class="s">        -------</span>
<span class="s">        chg : </span><span class="si">%(klass)s</span><span class="s"></span>

<span class="s">        Notes</span>
<span class="s">        -----</span>

<span class="s">        By default, the percentage change is calculated along the stat</span>
<span class="s">        axis: 0, or ``Index``, for ``DataFrame`` and 1, or ``minor`` for</span>
<span class="s">        ``Panel``. You can change this with the ``axis`` keyword argument.</span>
<span class="s">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;pct_change&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pct_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_method</span><span class="o">=</span><span class="s">&#39;pad&#39;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># TODO: Not sure if above is correct - need someone to confirm.</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;axis&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fill_method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">fill_method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

        <span class="n">rs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                                  <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">rs</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rs</span>

    <span class="k">def</span> <span class="nf">_agg_by_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">grouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">skipna</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">name</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">applyf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">method</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grouped</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">applyf</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_numeric_operations</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add the operations to the cls; evaluate the doc strings again &quot;&quot;&quot;</span>

        <span class="n">axis_descr</span> <span class="o">=</span> <span class="s">&quot;{</span><span class="si">%s</span><span class="s">}&quot;</span> <span class="o">%</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
            <span class="s">&quot;{0} ({1})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="o">.</span><span class="n">__name__</span>
                <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s">&#39;scalar&#39;</span><span class="p">)</span>

        <span class="n">_num_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>

<span class="si">%(desc)s</span><span class="s"></span>

<span class="s">Parameters</span>
<span class="s">----------</span>
<span class="s">axis : &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">axis_descr</span> <span class="o">+</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">skipna : boolean, default True</span>
<span class="s">    Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="s">    will be NA</span>
<span class="s">level : int or level name, default None</span>
<span class="s">        If the axis is a MultiIndex (hierarchical), count along a</span>
<span class="s">        particular level, collapsing into a &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">numeric_only : boolean, default None</span>
<span class="s">    Include only float, int, boolean data. If None, will attempt to use</span>
<span class="s">    everything, then use only numeric data</span>

<span class="s">Returns</span>
<span class="s">-------</span>
<span class="si">%(outname)s</span><span class="s"> : &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot; or &quot;</span> <span class="o">+</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&quot; (if level specified)</span><span class="se">\n</span><span class="s">&quot;</span>

        <span class="n">_bool_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>

<span class="si">%(desc)s</span><span class="s"></span>

<span class="s">Parameters</span>
<span class="s">----------</span>
<span class="s">axis : &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">axis_descr</span> <span class="o">+</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">skipna : boolean, default True</span>
<span class="s">    Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="s">    will be NA</span>
<span class="s">level : int or level name, default None</span>
<span class="s">        If the axis is a MultiIndex (hierarchical), count along a</span>
<span class="s">        particular level, collapsing into a &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">bool_only : boolean, default None</span>
<span class="s">    Include only boolean data. If None, will attempt to use everything,</span>
<span class="s">    then use only boolean data</span>

<span class="s">Returns</span>
<span class="s">-------</span>
<span class="si">%(outname)s</span><span class="s"> : &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot; or &quot;</span> <span class="o">+</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&quot; (if level specified)</span><span class="se">\n</span><span class="s">&quot;</span>

        <span class="n">_cnum_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>

<span class="s">Parameters</span>
<span class="s">----------</span>
<span class="s">axis : &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">axis_descr</span> <span class="o">+</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">skipna : boolean, default True</span>
<span class="s">    Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="s">    will be NA</span>

<span class="s">Returns</span>
<span class="s">-------</span>
<span class="si">%(outname)s</span><span class="s"> : &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>

        <span class="k">def</span> <span class="nf">_make_stat_function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>

            <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">)</span>
            <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_doc</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">stat_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                          <span class="n">numeric_only</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">skipna</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
                <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                              <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                    <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">)</span>
            <span class="n">stat_func</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">stat_func</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">sum</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="s">&#39;sum&#39;</span><span class="p">,</span> <span class="s">&#39;Return the sum of the values for the requested axis&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nansum</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="s">&#39;mean&#39;</span><span class="p">,</span> <span class="s">&#39;Return the mean of the values for the requested axis&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanmean</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">skew</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="s">&#39;skew&#39;</span><span class="p">,</span>
            <span class="s">&#39;Return unbiased skew over requested axis</span><span class="se">\n</span><span class="s">Normalized by N-1&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanskew</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">kurt</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="s">&#39;kurt&#39;</span><span class="p">,</span>
            <span class="s">&#39;Return unbiased kurtosis over requested axis using Fisher&#39;&#39;s &#39;</span>
            <span class="s">&#39;definition of</span><span class="se">\n</span><span class="s">kurtosis (kurtosis of normal == 0.0). Normalized &#39;</span>
            <span class="s">&#39;by N-1</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nankurt</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">kurtosis</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">kurt</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">prod</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="s">&#39;prod&#39;</span><span class="p">,</span> <span class="s">&#39;Return the product of the values for the requested axis&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanprod</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">product</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">prod</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">median</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="s">&#39;median&#39;</span><span class="p">,</span> <span class="s">&#39;Return the median of the values for the requested axis&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span><span class="s">&#39;max&#39;</span><span class="p">,</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">This method returns the maximum of the values in the object. If you</span>
<span class="s">want the *index* of the maximum, use ``idxmax``. This is the</span>
<span class="s">equivalent of the ``numpy.ndarray`` method ``argmax``.&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanmax</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span><span class="s">&#39;min&#39;</span><span class="p">,</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">This method returns the minimum of the values in the object. If you</span>
<span class="s">want the *index* of the minimum, use ``idxmin``. This is the</span>
<span class="s">equivalent of the ``numpy.ndarray`` method ``argmin``.&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanmin</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_make_logical_function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>

            <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">)</span>
            <span class="nd">@Appender</span><span class="p">(</span><span class="n">_bool_doc</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">logical_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bool_only</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                             <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">skipna</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
                <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">bool_only</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                            <span class="s">&quot;Option bool_only is not implemented with option &quot;</span>
                            <span class="s">&quot;level.&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                              <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                                    <span class="n">numeric_only</span><span class="o">=</span><span class="n">bool_only</span><span class="p">,</span> <span class="n">filter_type</span><span class="o">=</span><span class="s">&#39;bool&#39;</span><span class="p">,</span>
                                    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
            <span class="n">logical_func</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">logical_func</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">any</span> <span class="o">=</span> <span class="n">_make_logical_function</span><span class="p">(</span>
            <span class="s">&#39;any&#39;</span><span class="p">,</span> <span class="s">&#39;Return whether any element is True over requested axis&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanany</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">all</span> <span class="o">=</span> <span class="n">_make_logical_function</span><span class="p">(</span>
            <span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="s">&#39;Return whether all elements are True over requested axis&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanall</span><span class="p">)</span>

        <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="s">&#39;mad&#39;</span><span class="p">,</span>
                      <span class="n">desc</span><span class="o">=</span><span class="s">&quot;Return the mean absolute deviation of the values &quot;</span>
                           <span class="s">&quot;for the requested axis&quot;</span><span class="p">)</span>
        <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_doc</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">mad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">skipna</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span><span class="s">&#39;mad&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                          <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">demeaned</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">demeaned</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">demeaned</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">mad</span> <span class="o">=</span> <span class="n">mad</span>

        <span class="k">def</span> <span class="nf">_make_stat_function_ddof</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>

            <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">)</span>
            <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_doc</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">stat_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">numeric_only</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">skipna</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
                <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                              <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                    <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span>
                                    <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>
            <span class="n">stat_func</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">stat_func</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">sem</span> <span class="o">=</span> <span class="n">_make_stat_function_ddof</span><span class="p">(</span>
            <span class="s">&#39;sem&#39;</span><span class="p">,</span>
            <span class="s">&quot;Return unbiased standard error of the mean over &quot;</span>
            <span class="s">&quot;requested axis.</span><span class="se">\n\n</span><span class="s">Normalized by N-1 by default. &quot;</span>
            <span class="s">&quot;This can be changed using the ddof argument&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nansem</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">_make_stat_function_ddof</span><span class="p">(</span>
            <span class="s">&#39;var&#39;</span><span class="p">,</span>
            <span class="s">&quot;Return unbiased variance over requested &quot;</span>
            <span class="s">&quot;axis.</span><span class="se">\n\n</span><span class="s">Normalized by N-1 by default. &quot;</span>
            <span class="s">&quot;This can be changed using the ddof argument&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanvar</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="n">_make_stat_function_ddof</span><span class="p">(</span>
            <span class="s">&#39;std&#39;</span><span class="p">,</span>
            <span class="s">&quot;Return unbiased standard deviation over requested &quot;</span>
            <span class="s">&quot;axis.</span><span class="se">\n\n</span><span class="s">Normalized by N-1 by default. &quot;</span>
            <span class="s">&quot;This can be changed using the ddof argument&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanstd</span><span class="p">)</span>

        <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="s">&#39;compounded&#39;</span><span class="p">,</span>
                      <span class="n">desc</span><span class="o">=</span><span class="s">&quot;Return the compound percentage of the values for &quot;</span>
                           <span class="s">&quot;the requested axis&quot;</span><span class="p">)</span>
        <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_doc</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">compound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">skipna</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">compound</span> <span class="o">=</span> <span class="n">compound</span>

        <span class="k">def</span> <span class="nf">_make_cum_function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">accum_func</span><span class="p">,</span> <span class="n">mask_a</span><span class="p">,</span> <span class="n">mask_b</span><span class="p">):</span>

            <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
            <span class="nd">@Appender</span><span class="p">(</span><span class="s">&quot;Return cumulative {0} over requested axis.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                      <span class="o">+</span> <span class="n">_cnum_doc</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

                <span class="n">y</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">skipna</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                                         <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">)):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">accum_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">tslib</span><span class="o">.</span><span class="n">iNaT</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">skipna</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)):</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask_a</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">accum_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask_b</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">accum_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">()</span>
                <span class="n">d</span><span class="p">[</span><span class="s">&#39;copy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="n">func</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">func</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">cummin</span> <span class="o">=</span> <span class="n">_make_cum_function</span><span class="p">(</span>
            <span class="s">&#39;min&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">cumsum</span> <span class="o">=</span> <span class="n">_make_cum_function</span><span class="p">(</span>
            <span class="s">&#39;sum&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">cumprod</span> <span class="o">=</span> <span class="n">_make_cum_function</span><span class="p">(</span>
            <span class="s">&#39;prod&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">cummax</span> <span class="o">=</span> <span class="n">_make_cum_function</span><span class="p">(</span>
            <span class="s">&#39;max&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span>
            <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

<span class="c"># install the indexerse</span>
<span class="k">for</span> <span class="n">_name</span><span class="p">,</span> <span class="n">_indexer</span> <span class="ow">in</span> <span class="n">indexing</span><span class="o">.</span><span class="n">get_indexers_list</span><span class="p">():</span>
    <span class="n">NDFrame</span><span class="o">.</span><span class="n">_create_indexer</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">_indexer</span><span class="p">)</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Bernhard F.W. Gschaider.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.6.6',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>